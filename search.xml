<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LinuxC环境下线程池的实现]]></title>
    <url>%2F2018%2F08%2F06%2F009LinuxC%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近在准备毕业设计的系统实现部分，因为想让项目看上去更完整一些，所以学习了下线程池的相关知识，并且使用C复现出一个简单的线程池。 1. 为什么用线程池 创建/销毁线程伴随着系统开销，过于频繁的创建/销毁线程，会很大程度上影响处理效率 记创建线程消耗时间T1，执行任务消耗时间T2，销毁线程消耗时间T3 如果T1+T3&gt;T2，那么是不是说开启一个线程来执行这个任务太不划算了 然而，线程池缓存线程，可用已有的闲置线程来执行新任务，避免了T1+T3带来的系统开销 线程并发数量过多，抢占系统资源从而导致阻塞 我们知道线程能共享系统资源，如果同时执行的线程过多，就有可能导致系统资源不足而产生阻塞的情况 2.线程池的基本组成部分 线程池的管理线程（manager_thread）：用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务 工作线程（work_thread）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务 任务接口（threadpool_tast_t）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等 任务队列（tasks）：用于存放没有处理的任务。提供一种缓冲机制 3.代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471/*** @file threadpool.c* @brief 线程池* @details 线程池的简单实现，其中任务队列和线程组都是用循环队列实现的* @author xiangbin* @date 2018/08/05* @version 1.0*/#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;/** 基本错误类型 */#define ERR_BASE 8888/** malloc申请内存错误 */#define ERR_MALLOC ERR_BASE+1/** 函数的传入参数错误 */#define ERR_PARAMETER ERR_BASE+2/** 初始化mutex变量活着cond变量出错 */#define ERR_MUTEX_COND ERR_BASE+3/** 调试的时候使用，最后完成后会使用下面一个 */#define xb_printf(...) printf(__VA_ARGS__)//#define xb_printf(...)/** 管理线程睡眠时间 */#define DEFAULT_TIME_SPC 10/** 默认添加线程、减少线程的数量 */#define DEFAULT_THREAD_STEP 10/** 任务队列中的任务相关信息 */typedef struct threadpool_task&#123; void *(*function)(void *); ///&lt; 函数指针，回调函数 void *arg; ///&lt; 回调函数的参数&#125;threadpool_task_t;/** 线程池相关信息 */typedef struct threadpool&#123; pthread_mutex_t pool_lock; ///&lt; 本线程池的互斥锁，锁住的是整个结构体 pthread_mutex_t busy_lock; ///&lt; 变量busy_thr_num的锁 pthread_cond_t queue_not_full; ///&lt; 任务队列不为满条件变量，如果满了，阻塞等待 pthread_cond_t queue_not_empty; ///&lt; 任务队列不为空 /* 线程（数组）相关属性 */ int min_thr_num; ///&lt; 最小线程数量 int max_thr_num; ///&lt; 最大线程数量 int live_thr_num; ///&lt; 活着的线程数量 int busy_thr_num; ///&lt; 忙碌的线程数量，也就是正在干活的线程数量 int wait_exit_thr_num; ///&lt; 等待销毁的线程 pthread_t *threads; ///&lt; 线程数组（首地址） pthread_t manager_tid; ///&lt; 任务线程组管理线程，负责任务线程的增减 threadpool_task_t *tasks; ///&lt; 任务队列数组 /* 任务队列相关属性 */ int queue_front; ///&lt; 任务队列的队首 int queue_rear; ///&lt; 任务队列的队尾 int queue_size; ///&lt; 当前任务队列的长度 int queue_max_size; ///&lt; 任务队列的最大长度 int shutdown; ///&lt; 标志位，线程池使用状态 1:关闭，0：正在使用&#125;threadpool_t;int is_thread_alive(pthread_t tid);int threadpool_create(threadpool_t **p,int min_thr_num,int max_thr_num,int queue_max_size);void *work_thread(void *threadpool);void *manage_thread(void *threadpool);int threadpool_add_task(threadpool_t *pool, void*(*function)(void *arg), void *arg);int threadpool_free(threadpool_t **p);int threadpool_destroy(threadpool_t **p);/** * @brief 线程池的创建 * @param poll 线程池地址指针 * @param min_thr_num 线程池中线程的最小数量 * @param max_thr_num 线程池中线程的最大数量 * @param queue_max_size 线程池中任务队列的最大长度 * @return 成功，返回0；错误，返回错误代码 */int threadpool_create(threadpool_t **p,int min_thr_num,int max_thr_num,int queue_max_size)&#123; threadpool_t *pool = NULL; int ret = 0; int i = 0; do &#123; /** 动态申请内存，并且初始化 */ pool = (threadpool_t *)malloc(sizeof(threadpool_t)); if(NULL==pool) &#123; ret = ERR_MALLOC; break; &#125; /* 初始化参数 */ pool-&gt;min_thr_num = min_thr_num; pool-&gt;max_thr_num = max_thr_num; /* 活着的线程数 初值=最小线程数 */ pool-&gt;live_thr_num = min_thr_num; pool-&gt;busy_thr_num = 0; pool-&gt;wait_exit_thr_num = 0; pool-&gt;queue_front = 0; pool-&gt;queue_rear = 0; pool-&gt;queue_size = 0; pool-&gt;queue_max_size = queue_max_size; pool-&gt;shutdown = 0; /* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */ pool-&gt;threads = (pthread_t *)malloc(sizeof(pthread_t)*max_thr_num); if(NULL==pool-&gt;threads) &#123; ret = ERR_MALLOC; break; &#125; memset(pool-&gt;threads,0,sizeof(pthread_t)*max_thr_num); /* 申请队列的空间 */ pool-&gt;tasks = (threadpool_task_t *)malloc(sizeof(threadpool_task_t)*queue_max_size); if (NULL == pool-&gt;tasks) &#123; ret = ERR_MALLOC; break; &#125; /* 初始化互斥琐、条件变量 */ if (pthread_mutex_init(&amp;(pool-&gt;pool_lock), NULL) != 0 || pthread_mutex_init(&amp;(pool-&gt;busy_lock), NULL) != 0 || pthread_cond_init(&amp;(pool-&gt;queue_not_empty), NULL) != 0 || pthread_cond_init(&amp;(pool-&gt;queue_not_full), NULL) != 0) &#123; ret = ERR_MUTEX_COND; break; &#125; /* 初始化工作线程 */ for(i=0;i&lt;min_thr_num;i++) &#123; pthread_create(&amp;(pool-&gt;threads[i]), NULL, work_thread, (void *)pool);/*pool指向当前线程池*/ pthread_detach(pool-&gt;threads[i]); /* 分离线程，这样避免僵尸线程 */ xb_printf("start thread 0x%x...\n", (unsigned int)pool-&gt;threads[i]); &#125; /* 初始化管理线程 */ pthread_create(&amp;(pool-&gt;manager_tid), NULL, manage_thread, (void *)pool);/* 启动管理者线程 */ pthread_detach(pool-&gt;manager_tid);/* 分离线程，这样避免僵尸线程 */ *p = pool; &#125;while(0); //代替goto if(ret!=0) threadpool_free(&amp;pool); return ret;&#125;/** * @brief 线程池活着的线程处理函数（干活的线程） * @param threadpool 线程池的范型指针 * @return NULL值 */void *work_thread(void *threadpool)&#123; threadpool_t *pool = (threadpool_t *)threadpool; threadpool_task_t task; while(1) &#123; /*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/ pthread_mutex_lock(&amp;(pool-&gt;pool_lock)); while(pool-&gt;queue_size==0 &amp;&amp; !pool-&gt;shutdown) &#123; /* 阻塞等待条件满足 */ pthread_cond_wait( &amp;(pool-&gt;queue_not_empty),&amp;(pool-&gt;pool_lock) ); /*裁员（员工自杀方式）： 清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/ if(pool-&gt;wait_exit_thr_num&gt;0) &#123; pool-&gt;wait_exit_thr_num--; //这时候拿着pool-&gt;pool_lock锁呢 /*如果线程池里活着的线程个数大于最小值时可以结束当前空闲的线程*/ if(pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123; pool-&gt;live_thr_num--; // 杀死该进程 pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); xb_printf("thread 0x%x is exiting\n", (unsigned int)pthread_self()); pthread_exit(NULL); &#125; &#125; &#125;// end for: while(pool-&gt;queue_size==0 &amp;&amp; !pool-&gt;shutdown) /* 销毁的时候：关闭整个线程池 */ if (pool-&gt;shutdown) &#123;// pool-&gt;live_thr_num--; // 杀死该进程 pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); xb_printf("thread 0x%x is exiting\n", (unsigned int)pthread_self()); pthread_exit(NULL); /* 线程自行结束 */ &#125; /*干活：从任务队列里获取任务, 是一个出队操作*/ task = pool-&gt;tasks[pool-&gt;queue_front]; pool-&gt;queue_front = (pool-&gt;queue_front + 1) % pool-&gt;queue_max_size; pool-&gt;queue_size--; /*通知可以有新的任务添加进来*/ pthread_cond_broadcast(&amp;(pool-&gt;queue_not_full)); /*任务取出后，立即将 线程池琐 释放*/ pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); /*执行任务*/ xb_printf("thread 0x%x start working\n", (unsigned int)pthread_self()); pthread_mutex_lock(&amp;(pool-&gt;busy_lock)); pool-&gt;busy_thr_num++; pthread_mutex_unlock(&amp;(pool-&gt;busy_lock)); task.function(task.arg); /*任务结束处理*/ xb_printf("thread 0x%x end working\n", (unsigned int)pthread_self()); pthread_mutex_lock(&amp;(pool-&gt;busy_lock)); pool-&gt;busy_thr_num--; pthread_mutex_unlock(&amp;(pool-&gt;busy_lock)); &#125; // end for: while(1) return NULL;&#125;/** * @brief 线程池管理线程处理函数 * @param threadpool 线程池的范型指针 * @return NULL值 */void *manage_thread(void *threadpool)&#123; threadpool_t *pool = (threadpool_t *)threadpool; int i = 0; while(!pool-&gt;shutdown) &#123; /* 先睡眠一段时间，然后醒来处理线程的数量，人少-&gt;招人，人多-&gt;裁人 */ sleep(DEFAULT_TIME_SPC); if(pool-&gt;shutdown) break; // 在睡着的时候，被调用了destroy /*拿到相关的变量*/ pthread_mutex_lock(&amp;(pool-&gt;pool_lock));// int queue_size = pool-&gt;queue_size; int live_thr_num = pool-&gt;live_thr_num; pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); pthread_mutex_lock(&amp;(pool-&gt;busy_lock)); int busy_thr_num = pool-&gt;busy_thr_num; pthread_mutex_lock(&amp;(pool-&gt;busy_lock)); /* 增加线程：如果工作的线程占到总线程的80%（并且还没有达到最大的线程数量），那么增加线程数量 */ if( (busy_thr_num * 100 / live_thr_num &gt; 80) &amp;&amp; (live_thr_num &lt; pool-&gt;max_thr_num) ) &#123; pthread_mutex_lock(&amp;(pool-&gt;pool_lock)); // 加锁 int add = 0; // 查找一个空闲的数组地址（这个数组元素或者没有使用，或者线程被释放掉了） for(i=0;i&lt;pool-&gt;max_thr_num &amp;&amp; add &lt; DEFAULT_THREAD_STEP &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num ;i++) &#123; if(pool-&gt;threads[i]==0 || !is_thread_alive(pool-&gt;threads[i])) &#123; pthread_create(&amp;(pool-&gt;threads[i]), NULL, work_thread, (void *)pool);/*pool指向当前线程池*/ pthread_detach(pool-&gt;threads[i]); /* 分离线程，这样避免僵尸线程 */ add++; pool-&gt;live_thr_num++; &#125; &#125; // end for: for(i=0;i&lt;pool-&gt;max_thr_num &amp;&amp;... pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); // 解锁 &#125; /* 减少线程：如果有50%的线程干活，那么减少线程 */ if( busy_thr_num * 2 &lt; live_thr_num &amp;&amp; live_thr_num &gt; pool-&gt;min_thr_num) &#123; /* 设置要释放的线程数量 */ pthread_mutex_lock(&amp;(pool-&gt;pool_lock)); pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_STEP; /* 要销毁的线程数 设置为10 */ pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); for(i=0;i&lt;DEFAULT_THREAD_STEP;i++) &#123; pthread_cond_signal(&amp;(pool-&gt;queue_not_empty)); &#125; &#125; &#125; // end for： while(1) return NULL;&#125;/** * @brief 添加任务到线程池 * @param pool 线程池指针 * @param function 任务回调函数 * @param arg 任务回调函数的参数 * @return 成功，返回0；失败，返回-1 */int threadpool_add_task(threadpool_t *pool, void*(*function)(void *arg), void *arg)&#123; pthread_mutex_lock(&amp;(pool-&gt;pool_lock)); // 拿到锁 /* ==为真，队列已经满， 调wait阻塞 */ while(pool-&gt;queue_size==pool-&gt;queue_max_size &amp;&amp; !pool-&gt;shutdown) &#123; pthread_cond_wait(&amp;(pool-&gt;queue_not_full),&amp;(pool-&gt;pool_lock)); &#125; /* 线程池被关闭了 */ if (pool-&gt;shutdown) &#123; pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); return -1; &#125; /* 添加任务到队列 */ // 首先清空 if (pool-&gt;tasks[pool-&gt;queue_rear].arg != NULL) &#123; free(pool-&gt;tasks[pool-&gt;queue_rear].arg); pool-&gt;tasks[pool-&gt;queue_rear].arg = NULL; &#125; pool-&gt;tasks[pool-&gt;queue_rear].function = function; pool-&gt;tasks[pool-&gt;queue_rear].arg = arg; pool-&gt;queue_rear = (pool-&gt;queue_rear + 1) % pool-&gt;queue_max_size; /* 队尾指针移动, 模拟环形 */ pool-&gt;queue_size++; /*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/ pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); pthread_cond_signal(&amp;(pool-&gt;queue_not_empty)); return 0;&#125;/** * @brief 线程池销毁 * @param pool 线程池指针 * @return 成功，返回0；失败，返回-1 */int threadpool_destroy(threadpool_t **p)&#123; threadpool_t *pool = NULL; int i; if(NULL==p) return -1; pool = *p; /* 设置之后，管理线程醒来后可以退出了 */ pool-&gt;shutdown =1; /* 给每一个工作的线程发信号，让他们醒来，然后自杀*/ for (i = 0; i &lt; pool-&gt;live_thr_num; i++) &#123; pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty)); /*通知所有的空闲线程*/ &#125; /* 释放malloc申请的变量*/ return threadpool_free(p);&#125;/** * @brief 释放malloc申请的内存 * @param pool 线程池指针的指针 * @return 成功，返回0；失败，返回-1 */int threadpool_free(threadpool_t **p)&#123; threadpool_t *pool = NULL; if(NULL==p) return -1; pool = *p; if(NULL==pool) return -1; /* 首先,释放销毁锁和子线程 */ if(pool-&gt;threads) &#123; free(pool-&gt;threads); pthread_mutex_unlock(&amp;(pool-&gt;pool_lock)); pthread_mutex_destroy(&amp;(pool-&gt;pool_lock)); pthread_mutex_unlock(&amp;(pool-&gt;busy_lock)); pthread_mutex_destroy(&amp;(pool-&gt;busy_lock)); pthread_cond_destroy(&amp;(pool-&gt;queue_not_empty)); pthread_cond_destroy(&amp;(pool-&gt;queue_not_full)); &#125; /* 接着,释放销毁锁 */ if(pool-&gt;tasks) free(pool-&gt;tasks); /* 最后，销毁线程池 */ free(pool); *p= NULL; return 0;&#125;/** * @brief 判断某一个线程是否活着 * @param tid 被测试是否活着的线程 * @return 返回1，表示或者；返回0，表示没有或者 */int is_thread_alive(pthread_t tid)&#123; int ret = pthread_kill(tid, 0); //发0号信号，测试线程是否存活// ESRCH: No thread with the ID thread could be found. return (ret == ESRCH) ? 0: 1;// if (kill_rc == ESRCH) return 0;// return 1;&#125;#if 1void *hander_date(void *arg)&#123; int *p = (int *)arg; xb_printf("正在处理%d的数据\n",*p); sleep(1); xb_printf("==%d的数据处理成功\n",*p); return NULL;&#125;int main()&#123;// int threadpool_create(threadpool_t **p,int min_thr_num,int max_thr_num,int queue_max_size) threadpool_t *pool = NULL; int ret = threadpool_create(&amp;pool,10,100,1000); if(ret != 0) &#123; xb_printf("the threadpool is create failed!\n"); exit(-1); &#125; int i=0; int *num = (int *)malloc(sizeof(int) * 100); for(i=0;i&lt;100;i++) num[i]=i+1; // 添加任务 for(i=0;i&lt;100;i++) &#123;// int threadpool_add_task(threadpool_t *pool, void*(*function)(void *arg), void *arg) threadpool_add_task(pool,hander_date,(void *)&amp;num[i]); &#125; char c = getchar(); /* 等子线程完成任务 */ threadpool_destroy(&amp;pool); return 0;&#125;#endif]]></content>
      <categories>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>线程池</tag>
        <tag>线程同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PBC library在Linux系统中的安装]]></title>
    <url>%2F2018%2F07%2F11%2F008PBC-library%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Pairing-based cryptography library是在gmp库基础上开发的开源的C函数库，提供了对椭圆曲线群上的配对运算支持。本文主要针对PBC 官网的manual手册，学习使用PBC library。本文的实践环境为redhat 1. 安装Pbc library依赖的库 m4、flex、bison 在Linux系统中键入如下命令即可安装相应的包123yum install m4yum install flexyum install bison 2. 安装GMP库 GMP库下载地址如下：https://gmplib.org/ 下载并解压，在terminal里进入解压后的文件夹进行安装，方法如下1234./configuremakemake checkmake install(需要新建文件夹的权利sudo) 3. Pbc library库安装 pbc下载地址如下：http://crypto.stanford.edu/pbc/download.html 下载并解压，在terminal里进入解压文件夹安装，方法如下 123./configuremakemake install 至此pbc library 在redhat系统中的安装完成。接下来就是验证pbc库是否安装正确。 4. 编写简单的程序验证 首先找到头文件pbc.h的位置 1234在终端输入：find / -name pbc.h搜寻结果：/usr/local/include/pbc/pbc.h 接着找到库文件libgmp，libpbc 123456查找libgmp库：find / -name libgmp.*/usr/local/lib/libgmp.so 查找libpbc库：find / -name libpbc.*/usr/local/lib/libpbc.so 有了上述结果，我们就可以写一个简单的makefile了 1234start: gcc -o hello hello.c -L/usr/local/lib/ -lgmp -lpbc clean: rm -rf hello 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include "/usr/local/include/pbc/pbc.h" //必须包含头文件pbc.h#include "/usr/local/include/pbc/pbc_test.h"int main(int argc, char const *argv[]) &#123; pairing_t pairing; /* pairing_t定义： pairings where elements belong本例子用a.param去初始化pairing; a pairing is a map 例如:e:G1×G2-&gt;Gt a.param是pbc库中标准的参数集，其提供对称的pairing ，在所有的param中有最高的速度(根据看过的一篇论文中说明的没做实验～～) */ char s[16384]; FILE *fp = stdin; fp = fopen("a.param", "r"); if (!fp) pbc_die("error opening %s", argv[1]); size_t count = fread(s, 1, 16384, fp); if (!count) pbc_die("input error"); fclose(fp); if (pairing_init_set_buf(pairing, s, count)) pbc_die("pairing init failed"); //pairing 初始化结束 //定义变量-初始化-用于保存系统参数、公私秘钥以及其他变量 element_t g, h; element_t public_key, secret_key; element_t sig; element_t temp1, temp2; element_init_G2(g, pairing);//用pairing 初始化g element_init_G2(public_key, pairing); element_init_G1(h, pairing); element_init_G1(sig, pairing); element_init_GT(temp1, pairing); element_init_GT(temp2, pairing); element_init_Zr(secret_key, pairing); element_random(g);//随机生成g element_random(secret_key);//随机生成secret_key element_pow_zn(public_key, g, secret_key);//public_key = g^secret_key //当要对一个消息进行签名时，首先需要对其进行hash，使用一些标准的哈希算法，哈希过程没有涉及到pairing 所以 很遗憾pbc库中没有提供 element_from_hash(h, "ABCDEF", 6);//假设hash消息后得ABCDEF（48bit的哈希），这个函数的作用时map these bytes to an element h of G1 element_pow_zn(sig, h, secret_key);//sig = h^secret_key pairing_apply(temp1, sig, g, pairing);//temp1 = e(sig,g) pairing_apply(temp2, h, public_key, pairing); // e(h,public_key) if (!element_cmp(temp1, temp2)) &#123; //e(sig,g)=e(h^secret_key,g)//e(h,public_key)=e(h,g^secret_key)只要sig正确那么就有temp1=temp2 printf("signature verifies\n"); &#125; else &#123; printf("signature does not verify\n"); &#125; return 0;&#125; 5. 关于报错 运行的时候报错 ./hello 12./hello: error while loading shared libraries: libpbc.so .1: cannot open shared object file: No such file or directory 上次在安装oracle后运行程序也报告类似的错误，最后是添加一个环境变量解决的，所以这次应该也是这个梗。 尝试解决：添加库路径 123456789[root@localhost test_gmb]# cd /etc[root@localhost etc]# ls -a | grep ld.so.confld.so .confld.so .conf.d[root@localhost etc]# cat ld.so.confinclude ld.so.conf.d/*.conf[root@localhost etc]# vi ld.so.conf====》 添加pbc和gmp库的路径在最后一行，即 /usr/local/lib[root@localhost etc]# ldconfig 关于这个错误，更加详细的内容请参考：http://man.linuxde.net/ldconfig]]></content>
      <categories>
        <category>PBC</category>
      </categories>
      <tags>
        <tag>pbc</tag>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言操作Mysql数据库]]></title>
    <url>%2F2018%2F07%2F07%2F007C%E8%AF%AD%E8%A8%80%E6%93%8D%E4%BD%9CMysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1.Linux下安装Mysql数据库 Linux下安装Mysql数据库可以参考如下的链接：Linux rhel7 下MySQL5.7.18详细安装文档 网页丢失了，参考pdf文档，链接：https://pan.baidu.com/s/1GhfHThQxJ7iKTPstPtOAXw 密码：nx6s 以下的学习主要参考：MySQL 5.1参考手册，手册链接：https://pan.baidu.com/s/1GxMEjtOdIaBsnSOUndo7aw 密码：akll 2.基础知识2.1 测试环境 写一个.c文件测试编译环境是否正确，测试代码如下： 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;mysql.h&gt;int main()&#123; int ret = 0; // 1. init MYSQL mysql; if(mysql_init(&amp;mysql) == NULL) &#123; ret = mysql_errno(&amp;mysql); printf("func mysql_init error:%d\n",ret); return ret; &#125; // 2.close mysql_close(&amp;mysql); printf("hello word....\n"); return 0;&#125; C APIs包含在mysqlclient库文件当中，与MySQL的源代码一块发行，用于连接到数据库和执行数据库查询 在开发的时候，需要包含头文件mysql.h，和库mysqlclient.so 分别使用命令find / -name mysql.h和find / -name libmysqlclient.so查找 我的查询结果为：/usr/include/mysql/mysql.h和/usr/lib64/mysql/libmysqlclient.so 那么，在编译的时候使用的命令是：gcc -o hello hello.c -I/usr/include/mysql/ -L/usr/lib64/mysql/ -lmysqlclient 2.2 MYSQL C API的常用数据类型 MYSQL 该结构代表1个数据库连接的句柄。几乎所有的MYSQL函数均使用它。 MYSQL_RES 该结构代表返回行的查询结果 MYSQL_ROW 这是1行数据的”类型安全”表示。 MYSQL_FIELD 该结构包含关于字段的信息，如字段名、类型和大小等 MYSQL_FIELD_OFFSET 这时MYSQL字段列表偏移量的”类型安全”表示 my_ulonglong 用于行数以及mysql_affected_rows()、mysql_num_rows()和mysql_insert_id()的类型 2.3 编程步骤 1 通过调用mysql_init()初始化连接处理程序 2 通过调用mysql_real_connect()连接到服务器 3 发出SQL语句并处理其结果 4 通过调用mysql_close()，关闭与MYSQL服务器的连接 3.编程练习3.1 初始化、连接、关闭数据库 mysql_init() 12345678910MYSQL *mysql_init(MYSQL *mysql) 描述分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。返回值初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。错误在内存不足的情况下，返回NULL mysql_close() 12345678910void mysql_close(MYSQL *mysql) 描述关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。返回值无。错误无。 mysql_real_connect() 1234567891011121314MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 描述mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须成功完成。参数的指定方式如下：· 第1个参数应是已有MYSQL结构的地址。调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。通过mysql_options()调用，可更改多种连接选项。· “host”的值必须是主机名或IP地址。如果“host”是NULL或字符串&quot;localhost&quot;，连接将被视为与本地主机的连接。如果操作系统支持套接字（Unix）或命名管道（Windows），将使用它们而不是TCP/IP连接到服务器。· “user”参数包含用户的MySQL登录ID。如果“user”是NULL或空字符串&quot;&quot;，用户将被视为当前用户。在UNIX环境下，它是当前的登录名。在Windows ODBC下，必须明确指定当前用户名· “passwd”参数包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。这样，数据库管理员就能按特定的方式设置MySQL权限系统，根据用户是否拥有指定的密码，用户将获得不同的权限。· “db”是数据库名称。如果db为NULL，连接会将默认的数据库设为该值。· 如果“port”不是0，其值将用作TCP/IP连接的端口号。注意，“host”参数决定了连接的类型。· 如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道。注意，“host”参数决定了连接的类型。· client_flag的值通常为0 错误处理：mysql_error OR mysql_errno 一个小例子 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;mysql.h&gt;int main()&#123; int ret = 0; // 1. init MYSQL mysql; if(mysql_init(&amp;mysql) == NULL) &#123; ret = mysql_errno(&amp;mysql); printf("func mysql_init error:%d\n",ret); return ret; &#125; // 2. connect if(mysql_real_connect(&amp;mysql,"localhost","root","123","mydb61",0,NULL,0) == NULL) &#123; ret = mysql_errno(&amp;mysql); printf("func mysql_real_connect error:%d\n",ret); return ret; &#125; // 3. close mysql_close(&amp;mysql); printf("hello word....\n"); return 0;&#125; 补充：也可另一种方式来进行连接。先用MYSQL_READ_DEFAULT_FILE作为选项名来调用mysql_options(), 再调用mysql_real_connect()来连接服务器 mysql_options(*mysql, MYSQL_READ_DEFAULT_FILE, “my.cnf”) mysql_real_connect(*mysql, NULL, NULL, NULL, NULL, 0, NULL, 0) 说明：my.cnf文件中记录了连接MySQL服务器所需的各项参数（地址，端口，用户名，密码，数据库，字符集，Unix Socket等）。这样可以灵活的修改连接参数而不必重新编译程序 3.2 insert、update、select、delete 调用mysql_query()来执行SQL语句，如果语句中包含二进制数据，则需要调用mysql_real_query() 123456789int mysql_query(MYSQL *mysql, const char *query) 描述1.执行由“Null终结的字符串”查询指向的SQL查询。正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或“\g”。如果允许多语句执行，字符串可包含多条由分号隔开的语句。2.mysql_query()不能用于包含二进制数据的查询，应使用mysql_real_query()取而代之（二进制数据可能包含字符‘\0’，mysql_query()会将该字符解释为查询字符串结束）。3.如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查。返回值如果查询成功，返回0。如果出现错误，返回非0值 若执行的是UPDATE, DELETE或INSERT语句，则可通过mysql_affected_rows()获知受影响的记录数 12345678910111213141516171819my_ulonglong mysql_affected_rows(MYSQL *mysql) 描述返回上次UPDATE更改的行数，上次DELETE删除的行数，或上次INSERT语句插入的行数。对于UPDATE、DELETE或INSERT语句，可在mysql_query()后立刻调用。对于SELECT语句，mysql_affected_rows()的工作方式与mysql_num_rows()类似。返回值大于0的整数表明受影响或检索的行数。“0”表示UPDATE语句未更新记录，在查询中没有与WHERE匹配的行，或未执行查询。“-1”表示查询返回错误，或者，对于SELECT查询，在调用mysql_store_result()之前调用了mysql_affected_rows()。由于mysql_affected_rows()返回无符号值，通过比较返回值和“(my_ulonglong)-1”或等效的“(my_ulonglong)~0”，检查是否为“-1”。错误无。示例：mysql_query(&amp;mysql,&quot;UPDATE products SET cost=cost*1.25 WHERE group=10&quot;);printf(&quot;%ld products updated&quot;,(long) mysql_affected_rows(&amp;mysql));如果在连接至mysqld时指定了标志CLIENT_FOUND_ROWS，对于UPDATE语句，mysql_affected_rows()将返回WHERE语句匹配的行数。注意，使用REPLACE命令时，如果新行替代了旧行，mysql_affected_rows()返回2。这是因为，在该情况下，删除了重复行后插入了1行。如果使用“INSERT ... ON DUPLICATE KEY UPDATE”来插入行，如果行是作为新行插入的，mysql_affected_rows()返回1，如果是更新了已有的行，返回2。 若执行的是SELECT语句，则有两种方式来获取结果集 一种方式是通过mysql_store_result()将整个结果集全部取回来 1234567891011121314MYSQL_RES *mysql_store_result(MYSQL *mysql) 描述1.对于成功检索了数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN、CHECK TABLE等），必须调用mysql_store_result()或mysql_use_result() 。2.对于其他查询，不需要调用mysql_store_result()或mysql_use_result()，但是如果在任何情况下均调用了mysql_store_result()，它也不会导致任何伤害或性能降低。通过检查mysql_store_result()是否返回0，可检测查询是否没有结果集（以后会更多）。3.如果希望了解查询是否应返回结果集，可使用mysql_field_count()进行检查mysql_store_result()将查询的全部结果读取到客户端，分配1个MYSQL_RES结构，并将结果置于该结构中。4.如果查询未返回结果集，mysql_store_result()将返回Null指针（例如，如果查询是INSERT语句）。5.一旦调用了mysql_store_result()并获得了不是Null指针的结果，可调用mysql_num_rows()来找出结果集中的行数。6.可以调用mysql_fetch_row()来获取结果集中的行，或调用mysql_row_seek()和mysql_row_tell()来获取或设置结果集中的当前行位置。7.一旦完成了对结果集的操作，必须调用mysql_free_result()。返回值具有多个结果的MYSQL_RES结果集合。如果出现错误，返回NULL。 另一种方式则是调用mysql_use_result()初始化获取操作，但暂时不取回任何记录 1234567891011MYSQL_RES *mysql_use_result(MYSQL *mysql) 描述1.对于成功检索数据的每个查询（SELECT、SHOW、DESCRIBE、EXPLAIN），必须调用mysql_store_result()或mysql_use_result()。2.mysql_use_result()将初始化结果集检索，但并不像mysql_store_result()那样将结果集实际读取到客户端。它必须通过对mysql_fetch_row()的调用，对每一行分别进行检索。这将直接从服务器读取结果，而不会将其保存在临时表或本地缓冲区内，与mysql_store_result()相比，速度更快而且使用的内存也更少。客户端仅为当前行和通信缓冲区分配内存，分配的内存可增加到max_allowed_packet字节。3.不应与从mysql_use_result()返回的结果一起使用mysql_data_seek()、mysql_row_seek()、mysql_row_tell()、mysql_num_rows()或mysql_affected_rows()，也不应发出其他查询，直至mysql_use_result()完成为止。（但是，提取了所有行后，mysql_num_rows()将准确返回提取的行数）。4.一旦完成了对结果集的操作，必须调用mysql_free_result()。5.使用libmysqld嵌入式服务器时，由于在调用mysql_free_result()之前，内存使用将随着每个检索的行增加，内存效益将基本丧失。返回值MYSQL_RES结果结构。如果出现错误，返回NULL。 两种方法均通过mysql_fetch_row()来访问每一条记录 123456789MYSQL_ROW mysql_fetch_row(MYSQL_RES *result) 描述1.检索结果集的下一行。在mysql_store_result()之后使用时，如果没有要检索的行，mysql_fetch_row()返回NULL。在mysql_use_result()之后使用时，如果没有要检索的行或出现了错误，mysql_fetch_row()返回NULL。2.行内值的数目由mysql_num_fields(result)给出。如果行中保存了调用mysql_fetch_row()返回的值，将按照row[0]到row[mysql_num_fields(result)-1]，访问这些值的指针。行中的NULL值由NULL指针指明。3.可以通过调用mysql_fetch_lengths()来获得行中字段值的长度。对于空字段以及包含NULL的字段，长度为0。通过检查字段值的指针，能够区分它们。如果指针为NULL，字段为NULL，否则字段为空。返回值下一行的MYSQL_ROW结构。如果没有更多要检索的行或出现了错误，返回NULL。 当处理完结果集后，调用mysql_free_result()来释放它所占的内存 1234567891011void mysql_free_result(MYSQL_RES *result) 描述1.释放由mysql_store_result()、mysql_use_result()、mysql_list_dbs()等为结果集分配的内存。完成对结果集的操作后，必须调用mysql_free_result()释放结果集使用的内存。2.释放完成后，不要尝试访问结果集。返回值无。错误无。 一个小例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;mysql.h&gt;int main()&#123; int ret = 0; // 1. init MYSQL mysql; if(mysql_init(&amp;mysql) == NULL) &#123; ret = mysql_errno(&amp;mysql); printf("func mysql_init error:%d\n",ret); return ret; &#125; // 2. connect if(mysql_real_connect(&amp;mysql,"localhost","root","123","mydb61",0,NULL,0) == NULL) &#123; ret = mysql_errno(&amp;mysql); printf("func mysql_real_connect error:%d\n",ret); return ret; &#125; // 3. select char *sql = "select * from dept"; ret = mysql_query(&amp;mysql,sql); if(ret!=0) &#123; ret = mysql_errno(&amp;mysql); printf("func mysql_query error:%d\n",ret); return ret; &#125; MYSQL_RES *result = mysql_store_result(&amp;mysql); if(result==NULL) &#123; ret = mysql_errno(&amp;mysql); printf("func mysql_store_result error:%d\n",ret); return ret; &#125; MYSQL_ROW row = NULL; // int ncols = mysql_num_fields(result); int ncols = mysql_field_count(&amp;mysql); int i=0; while(row = mysql_fetch_row(result)) &#123; //printf("%s\t%s\t%s\t\n",row[0],row[1],row[2]); for(i=0;i&lt;ncols;i++) printf("%s\t",row[i]); printf("\n"); &#125; mysql_free_result(result); // 4. close mysql_close(&amp;mysql); printf("hello word....\n"); return 0;&#125; 3.3 乱码问题解决：query的时候设置解析方式 可以在所有的查询之前设置一下 12mysql_query(&amp;mysql,&quot;set names utf8&quot;);ret = mysql_query(&amp;mysql,sql); 也可以每一次查询的时候都设置一次 4. 预处理语句 MySQL C API还提供了另一种方式来执行SQL语句，即先预处理(prepare)再执行(execute)。 对于多次执行的SQL语句，该方式可以提高其执行效率 具体步骤 123456789101112131415161718192021222324252627282930313233343536373839401. 调用mysql_stmt_init()创建语句句柄，该句柄在随后的函数调用中都要用到。MYSQL_STMT *mysql_stmt_init(MYSQL *mysql)2. 调用mysql_stmt_prepare()对SQL语句进行预处理int mysql_stmt_prepare(MYSQL_STMT *stmt, const char *stmt_str, unsigned long length)3. 如果SQL语句中有参数，则需要调用mysql_stmt_bind_param()进行参数绑定。my_bool mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *bind)如果参数的类型为TEXT或BLOB, 并且数据量很大，可以调用mysql_stmt_send_long_data()来向服务器发送数据。my_bool mysql_stmt_send_long_data(MYSQL_STMT *stmt, unsigned int parameter_number,const char *data, unsigned long length)4. 调用mysql_stmt_execute()来执行查询。int mysql_stmt_execute(MYSQL_STMT *stmt)5. 若查询不产生结果集，可以调用mysql_stmt_affected_rows()和my_ulonglong mysql_stmt_insert_id(MYSQL_STMT *stmt)来获得被改变的记录数和生成的自增值。my_ulonglong mysql_stmt_affected_rows(MYSQL_STMT *stmt)my_ulonglong mysql_stmt_insert_id(MYSQL_STMT *stmt)否则，执行mysql_stmt_bind_result()对结果集中的字段进行绑定。my_bool mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *bind)6. 调用mysql_stmt_fetch()来逐行获取结果集中的记录。int mysql_stmt_fetch(MYSQL_STMT *stmt)在调用mysql_stmt_fetch()之前，还可以执行mysql_stmt_store_result()将结果集预先缓存到本地。int mysql_stmt_store_result(MYSQL_STMT *stmt)7. 重复步骤3-6, 每次使用不同的实参来执行查询。8. 调用mysql_stmt_close()关闭句柄，释放资源my_bool mysql_stmt_close(MYSQL_STMT *)此外，可以调用mysql_stmt_errno()和mysql_stmt_error()来获知最近执行的预处理语句API函数的错误代码和错误信息。unsigned int mysql_stmt_errno(MYSQL_STMT *stmt)const char *mysql_stmt_error(MYSQL_STMT *stmt)9.其他说明：mysql_stmt_execute()中有调用案例 一个例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;dlfcn.h&gt;#include &lt;mysql/mysql.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;termios.h&gt;#include &lt;mysql/mysql.h&gt;#include &lt;termios.h&gt;#define STRING_SIZE 50#define DROP_SAMPLE_TABLE "DROP TABLE IF EXISTS test_table"#define CREATE_SAMPLE_TABLE "CREATE TABLE test_table(col1 INT,\ col2 VARCHAR(40),\ col3 SMALLINT,\ col4 TIMESTAMP)"#define INSERT_SAMPLE "INSERT INTO test_table(col1,col2,col3) VALUES(?,?,?)"int main(int arg, char *args[])&#123; int ret = 0, i=0; MYSQL *mysql; MYSQL_RES *result; MYSQL_ROW row; MYSQL_FIELD *fields; unsigned int num_fields; mysql = mysql_init(NULL); if (mysql == NULL) &#123; ret = mysql_errno(mysql) ; printf("connect error, %s\n", mysql_error(mysql)); goto END; &#125; //连接到mysql server mysql = mysql_real_connect(mysql, "localhost", "root", "123456", "mydb2", 0, NULL, 0); if (mysql == NULL) &#123; ret = mysql_errno(mysql) ; printf("connect error, %s\n", mysql_error(mysql)); goto END; &#125; //////////////////////////////////////////////////////////////////// MYSQL_STMT *stmt; MYSQL_BIND bind[3]; my_ulonglong affected_rows; int param_count; short small_data; int int_data; char str_data[STRING_SIZE]; unsigned long str_length; my_bool is_null; if (mysql_query(mysql, DROP_SAMPLE_TABLE)) &#123; fprintf(stderr, " DROP TABLE failed\n"); fprintf(stderr, " %s\n", mysql_error(mysql)); exit(0); &#125; if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) &#123; fprintf(stderr, " CREATE TABLE failed\n"); fprintf(stderr, " %s\n", mysql_error(mysql)); exit(0); &#125; /* Prepare an INSERT query with 3 parameters */ /* (the TIMESTAMP column is not named; the server */ /* sets it to the current date and time) */ stmt = mysql_stmt_init(mysql); //初始化预处理环境句柄 if (!stmt) &#123; fprintf(stderr, " mysql_stmt_init(), out of memory\n"); exit(0); &#125; if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE))) //向预处理环境句柄添加sql(???) &#123; fprintf(stderr, " mysql_stmt_prepare(), INSERT failed\n"); fprintf(stderr, " %s\n", mysql_stmt_error(stmt)); exit(0); &#125; fprintf(stdout, " prepare, INSERT successful\n"); /* Get the parameter count from the statement */ param_count= mysql_stmt_param_count(stmt); fprintf(stdout, " total parameters in INSERT: %d\n", param_count); if (param_count != 3) /* validate parameter count */ &#123; fprintf(stderr, " invalid parameter count returned by MySQL\n"); exit(0); &#125; /* Bind the data for all 3 parameters */ memset(bind, 0, sizeof(bind)); /* INTEGER PARAM */ /* This is a number type, so there is no need to specify buffer_length */ bind[0].buffer_type= MYSQL_TYPE_LONG; bind[0].buffer= (char *)&amp;int_data; bind[0].is_null= 0; //0 bind[0].length= 0; /* STRING PARAM */ bind[1].buffer_type= MYSQL_TYPE_STRING; bind[1].buffer= (char *)str_data; bind[1].buffer_length= STRING_SIZE; bind[1].is_null= 0; bind[1].length= &amp;str_length; /* SMALLINT PARAM */ bind[2].buffer_type= MYSQL_TYPE_SHORT; bind[2].buffer= (char *)&amp;small_data; bind[2].is_null= &amp;is_null; bind[2].length= 0; /* Bind the buffers */ if (mysql_stmt_bind_param(stmt, bind)) //把数组 添加到//向预处理环境句柄 &#123; fprintf(stderr, " mysql_stmt_bind_param() failed\n"); fprintf(stderr, " %s\n", mysql_stmt_error(stmt)); exit(0); &#125; /* Specify the data values for the first row */ int_data= 10; /* integer */ strncpy(str_data, "MySQL", STRING_SIZE); /* string */ str_length= strlen(str_data); /* INSERT SMALLINT data as NULL */ is_null= 1; /* Execute the INSERT statement - 1*/ if (mysql_stmt_execute(stmt)) //执行sql &#123; fprintf(stderr, " mysql_stmt_execute(), 1 failed\n"); fprintf(stderr, " %s\n", mysql_stmt_error(stmt)); exit(0); &#125; /* Get the total number of affected rows */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, " total affected rows(insert 1): %lu\n", (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ &#123; fprintf(stderr, " invalid affected rows by MySQL\n"); exit(0); &#125; /* Specify data values for second row, then re-execute the statement */ int_data= 1000; strncpy(str_data, "The most popular Open Source database", STRING_SIZE); str_length= strlen(str_data); small_data= 1000; /* smallint */ is_null= 0; /* reset */ /* Execute the INSERT statement - 2*/ if (mysql_stmt_execute(stmt)) //再执行 &#123; fprintf(stderr, " mysql_stmt_execute, 2 failed\n"); fprintf(stderr, " %s\n", mysql_stmt_error(stmt)); exit(0); &#125; /* Get the total rows affected */ affected_rows= mysql_stmt_affected_rows(stmt); fprintf(stdout, " total affected rows(insert 2): %lu\n", (unsigned long) affected_rows); if (affected_rows != 1) /* validate affected rows */ &#123; fprintf(stderr, " invalid affected rows by MySQL\n"); exit(0); &#125; /* Close the statement */ if (mysql_stmt_close(stmt)) &#123; fprintf(stderr, " failed while closing the statement\n"); fprintf(stderr, " %s\n", mysql_stmt_error(stmt)); exit(0); &#125;END: if (mysql != NULL) mysql_close(mysql); //断开与SQL server的连接 return 0;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>嵌入式SQL</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle Pro*C 编程入门]]></title>
    <url>%2F2018%2F07%2F05%2F006Oracle-Pro-C-%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. 概念1.1 什么是Pro*c程序 在oracle数据库管理系统中，有三种访问数据库的方法： 1.用 SQL*Plus，直接输入sql命令以命令行交换的方式访问数据库 2.用一些应用开发工具来访问数据库(PL/SQL developer) 3.利用在语言内嵌入sql语言或者调用oracle库函数来访问数据库，例如Pro*c Pro*C把过程化语言c和非过程化语言sql最完善的结合起来，具有完备的过程处理能力，又能完成任何数据库的处理任务，使用户可以通过编程完成各种类型的报表。 在Pro*C程序中嵌入sql语言，利用这些sql语言可以完成动态地建立、修改和删除数据库中的表，也可以查询、插入、修改和删除数据库表中的行，还可以实现事务的提交和回滚。 一句话，通过在过程化编程语言C/C++中嵌入SQL语句而开发出的应用程序 补充1：什么是嵌入式SQL？ 在通用编程语言中使用的SQL称为嵌入式SQL 在SQL标准中定义了多种语言的嵌入式SQL 各个厂商对嵌入式SQL的具体实现不同 补充2：什么是宿主语言？ 嵌入式SQL的载体是宿主语言 1.2 Oracle 预编译器 功能：完成Pro*C源程序到纯C源程序的转换 Pro*c/c++应用程序完整开发流程 普通c程序: C源文件(.c) -&gt; 目标文件(.o) -&gt; 可执行文件 Pro*c/c++程序: Pro*C 源文件(.pc) -&gt; C源文件(.c) -&gt; 目标文件(.o) -&gt; 可执行文件 基本命令格式(.pc -&gt; .c/.cc) 1234567891011121314151617proc iname=filename [OptionName1=value1]…[OptionNameN=valueN]1.常用编译选项: INAME=path and filename (name of the input file) 1.pc ONAME=path and filename (name of the output file) 1.c 1.cc INCLUDE=path (头文件所在路径） --INCLUDE =路径名 或 INCLUDE =(路径名1,路径名2) PARSE=FULL | PARTIA | NONE (default FULL for C, Others for C++) CODE=ANSI_C | CPP (default ansi_c) USERID=username/password2.编译1个含有嵌入式SQL的C++ (hello.pc用C++语法写的):parse=none 告诉proc编译器 按照c++规范解析 dm02_hello.pccode=cpp 告诉proc编译器 按照c++规范 生产文件proc hello.pc parse=none code=cpp oname=hello.cc3.编译1个含有嵌入式SQL的C (hello.pc用C语法写的):proc hello.pc 2. Pro*C 语法结构2.1 嵌入 SQL 语句在程序中的标志 嵌入式语句以 EXEC SQL 开头， 以分号结束 2.2 换行 当一行写不下一条嵌入式 SQL 语句时， 可以用反斜线()换行(也可以不用, 但为了程序的可读性好一些， 建议使用) 2.3 程序结构 每一个 Pro*C 程序都包括两部分：（1）应用程序首部；（2）应用程序体 应用程序首部定义了 ORACLE 数据库的有关变量， 为在 C 语言中操纵 ORACLE 数据库做好了准备 应用程序体基本上由 Pro*C 的 SQL 语句调用组成。主要指查询SELECT、INSERT、UPDATE、DELETE 等语句 应用程序的组成结构如图所示: 2.4 大小写 嵌入式语句内不区分大小写 2.5 宿主变量 宿主变量的使用是为了实现 Oracle 数据库和应用程序之间的数据通信 定义: Pro*C 中宿主变量有两种定义方法 ANSI 方法 按照 ANSI 标准， 只有在 Pro*C 预编译程序的宿主变量声明区内声明的变量才能做为宿主变量 宿主变量声明区域为 EXEC SQL BEGIN DECLARE SECTION和 EXEC SQL END DECLARE SECTION 语句之间的区域 Oracle 方法 Oracle 对 ANSI 标准进行了扩充， 它允许在程序中的任何部分声明宿主变量 所以， 当把预编译选项 MODE 设为 ORACLE 时， 应用程序不必在指定的声明区域内声明宿主变量 使用: SQL 语句或 PL/SQL 块参照宿主变量时， 必须在宿主变量名称前加冒号, 以区别于 Oracle 数据库对象名称 但在 C 语句在使用这些变量时， 则不能加冒号 注意： Pro*C 应用程序中不能使用宿主变量提供数据库对象名称， 所以， 在CREATE, ALTER 和 DROP 等 DDL 语句中不能使用输入宿主变量 3. 小试牛刀：Pro*C/C++开发基础3.1 开发流程 编写.pc代码(hello.pc) 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"int main()&#123; printf("ok...\n"); return 0;&#125; 使用proc编译，在当前目录下打开终端，输入 proc hello.pc 使用gcc编译 1.要找到sqlca.h的位置，打开终端输入 find / -name sqlca.h 查询结果为：/u01/app/oracle/product/12.2/db_1/precomp/public/sqlca.h 2.接着，要找到使用的动态库libclntsh.so, 打开终端输入 find / -name libclntsh.so 查询结果为：/u01/app/oracle/product/12.2/db_1/lib/libclntsh.so ok，现在可以编写gcc命令了，在当前目录下打开终端，输入 gcc -o hello hello.c -I/u01/app/oracle/product/12.2/db_1/precomp/public/ -L/u01/app/oracle/product/12.2/db_1/lib/ -lclntsh 运行hello程序， 在当前目录下打开终端，输入 ./hello 如果上述过程没有问题，那么恭喜，整个开发流程没有错误。 这里我实践的时候，报了一堆堆错误，找到第一条后，发现是大致的意思是：proc工具预编译时找不到stddef.h PCC-S-02015, unable to open include file Error at line 15, column 10 in file /usr/include/_G_config.h #include &lt;stddef.h&gt; 解决方法（pcscfg.cfg这个文件配置有错误）： 1.找到文件pcscfg.cfg的位置， find / -name pcscfg.cfg 2.找到stddef.h文件的位置和版本信息， find / -name stddef.h 3.打开1中文件pcscfg.cfg文件，替换stddef.h路径和版本信息 3.2 连接数据库 上述流程全部OK后，我们接着从连接数据库开始，连接数据库有3种方法 12345678-- 方法1EXEC SQL CONNECT :usr_pwd;-- 方法2EXEC SQL CONNECT :username IDENTIFIED BY :password ;-- 方法3/* connect to the nondefault database using db_name */EXEC SQL CONNECT :username IDENTIFIED BY :password AT :db_name USING :db_string; 这里提供一个使用方法1的例子：使用用户名xiangbin，密码xb1207，连接orcl 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb1207@orcl";EXEC SQL END DECLARE SECTION;int main()&#123; printf("serversid: %s\n",serversid); EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit release; printf("connect ok...\n"); return 0;&#125; 几点说明： #include &quot;sqlca.h&quot; 为要包含的头文件 sqlca是一个结构类型的变量，它是oracle和应用程序的一个接口。在执行Pro*C程序时，oracle把每一个嵌入SQL语句执行的状态信息存入sqlca中，根据这些信息，可判断SQL语句的执行是否成功，处理的行数，错误信息等，结构体组成如下所示： 1234567891011121314151617struct sqlca&#123; char sqlcaid[8]; //标识通讯区 long sqlabc; //通序区的长度 long sqlcode; //最近执行的SQL语句的状态码 struct&#123; unsigned sqlerrml;//信息文本长度 char sqlerrmc[10];//错误正文 &#125;sqlerrm; char sqlerrp[8]; char sqlerrd[6];//当前oracle的状态，sqlerrd[2]才有意义，表示DML语句处理的行数 char sqlwarn[8];//提供可能遇到的条件信息 char sqlext[8];&#125;;struct sqlca sqlca; sqlcode的值如下： 等于0 表示SQL语句被正确执行 大于0 oracle执行了该语句，但遇到一个例外（例如没有找到任何数据） 小于0 表示由于数据库、系统、网络或者应用程序的错误，oracle未执行该语句，当出现这一类错误时，当前事务一般应该回滚。 another example: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char user[20]=&#123;0&#125;; char pwd[20] =&#123;0&#125;; char dbname[20]=&#123;0&#125;;EXEC SQL END DECLARE SECTION;int main()&#123; //printf("serversid: %s\n",serversid); strcpy(user,"xiangbin"); strcpy(pwd,"xb1207"); strcpy(dbname,"orcl"); //EXEC SQL connect :serversid; EXEC SQL CONNECT :user IDENTIFIED BY :pwd USING :dbname; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit release; printf("connect ok...\n"); return 0;&#125; 3.3 数据的 insert、update、delete、select insert、update、delete、select对应的代码分别如下 这里select是简单的使用，只查询1行，详细的使用后面的小节 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb1207@orcl"; int deptno; char dname[20]=&#123;0&#125;; char loc[20]=&#123;0&#125;; int deptno2; char dname2[20]; char loc2[20];EXEC SQL END DECLARE SECTION;// ======================== 1. connect ======================== //int main_coon()&#123; printf("serversid: %s\n",serversid); EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 2. insert ======================== //int main_insert()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // insert deptno = 50; strcpy(dname,"YIZHEN"); strcpy(loc,"YIZHEN"); EXEC SQL insert into test(deptno,dname,loc) values (:deptno,:dname,:loc); if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 3. update ======================== //int main_update()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // insert deptno = 50; printf("Enter the dname:"); scanf("%s",dname); EXEC SQL update test set dname=:dname where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 4. delete ======================== //int main_delete()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // delete deptno = 10; EXEC SQL delete test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 5. select ======================== //int main()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // select deptno = 10; EXEC SQL select deptno,dname,loc into :deptno2,:dname2,:loc2 from test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("select ok...\n"); printf("deptno=%d, dname=%s,loc=%s\n",deptno2,dname2,loc2); EXEC SQL commit release; return 0;&#125; 4. 循序渐进：Pro*C/C++开发提高4.1 中文乱码问题 乱码来源，这里使用的是SecureCRT连接远程的RedHat SecureCRT的字符集 解决：在SecureCRT的设置选项中设置下就好 RedHat数据库字符集的设置 解决：来到oracle用户的家目录下，打开该目录下的.bash_profile文件，添加环境变量12export NLS_LANG="SIMPLIFIED CHINESE_CHINA.ZHS16GBK"（简体中文gbk）export NLS_LANG="SIMPLIFIED CHINESE_CHINA.AL32UTF8"（简体中文utf8）===&gt; 这个比较好 4.2 宿主变量和指示器变量 宿主变量 宿主变量是一种Pro*c语言变量, 用于在应用程序中和oracle数据库之间传递数据 Pro*C程序中，既可在SQL语句中引用，也可在C语句中引用的变量称为SQL变量 其申明语法与普通C变量一致，但在CODE=CPP或 MODE=ANSI 时变量必须放在申明区 可使用pointer 作为宿主变量，使用前分配空间 在DDL语句中不能用宿主变量 。错误例子： 123char table_name[30];cin&gt;&gt;table_name;EXEC SQL DROP TABLE :table_name; 宿主变量的数据类型 宿主变量的使用 输入 – 将应用程序的数据传递到数据库中 输出 – 将数据库的数据传递到应用程序中 12345678910111、input example:int salary, emp_number;cin&gt;&gt;salary;cin&gt;&gt;emp_number;EXEC SQL update emp set sal=:salary where empno= :emp_number;2、output example:float v_salary;char v_job;EXEC SQL select sal,job INTO :v_salary, :v_job from emp where empno = 7788;cout&lt;&lt;v_salary&lt;&lt;v_job; 预编译选项 CHAR_MAP CHAR_MAP=CHARZ (默认设置): ‘\0’结尾，定长，空格补齐 ==&gt;(也就数说，当char danme[20]中从数据库中读取的数据长度没有20个字节的时候，他用空格给你填充到19，然后最后一位’\0’) CHAR_MAP=CHARF | VARCHAR2：定长，空格补齐 CHAR_MAP=STRING： ‘\0’结尾，变长 VARCHAR 变长, 不是‘\0’结尾 在proc编译成.c的时候，会解释成如下格式1234Struct&#123; unsigned short len; unsigned char arr[ ]; &#125;variable_name 综合使用的一个例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parametertypedef char (TypeStr)[20]; // a)EXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb1207@orcl"; int deptno; char dname[20]=&#123;0&#125;; char loc[20]=&#123;0&#125;; int deptno2; char dname2[20]; char loc2[20]; int deptno3; varchar dname3[20]; varchar loc3[20]; // b) EXEC SQL TYPE TypeStr is string(20); // c) int deptno4; TypeStr dname4; TypeStr loc4;EXEC SQL END DECLARE SECTION;int main()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // select deptno = 10; // 1. white space is contained in the output of printf // deptno=10, dname=AAA ,loc=10AAA EXEC SQL select deptno,dname,loc into :deptno2,:dname2,:loc2 from test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("deptno=%d, dname=%s,loc=%s\n",deptno2,dname2,loc2); // 2. white space is not contained in the output of printf // deptno=10, dname=AAA,loc=10AAA EXEC SQL select deptno,dname,loc into :deptno3,:dname3,:loc3 from test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("deptno=%d, dname=%s,loc=%s\n",deptno3,dname3.arr,loc3.arr); // 3. white space is not contained in the output of printf // deptno=10, dname=AAA,loc=10AAA EXEC SQL select deptno,dname,loc into :deptno4,:dname4,:loc4 from test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("deptno=%d, dname=%s,loc=%s\n",deptno4,dname4,loc4); printf("select ok...over.....\n"); EXEC SQL commit release; return 0;&#125; 指示器变量 短整型变量，用于处理数据库的NULL值，监督和管理与其相关联的宿主变量(短整型，短整型，短整型) 引用语法：:host_variable INDICATOR :indicator_variable OR :host_variable:indicator_variable 如果输入的变量中加入了指示器变量，并且指示器变量的值为-1，那么无论输入变量输入是否有值，插入数据库的都是NULL 我们可以通过在SQL语句的输出变量后面加上指示器变量，然后通过判断指示器变量的值是否是-1，从而确定读取的输出变量是否为NULL 取值的具体含义 -1：数据库表列的值为NULL，指示变量相关联的输出宿主变量值不确定 等于0：Oracle将数据库表列值原封不动的赋给指示器变量相关联的输出宿主变量 大于0： Oracle将数据库表列值截断后赋给指示器变量相关联的输出宿主变量，指示器变量值为该列值的原始长度 1234567891011EXEC SQL BEGIN DECLARE SECTION; char desc[35]; short ind_desc;EXEC SQL END DECLARE SECTION;…EXEC SQL SELECT emp_desc INTO :desc :ind_desc FROM emp WHERE emp_no=7788;if(ind_desc &lt; 0) cout&lt;&lt;“emp_desc is NULL”;else cout&lt;&lt; desc &lt;&lt; endl; 关于指示器变量使用的一个小例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb1207@orcl"; int deptno; char dname[20]=&#123;0&#125;; char loc[20]=&#123;0&#125;; short loc_ind; int deptno2; char dname2[20]; char loc2[20]; short loc2_ind;EXEC SQL END DECLARE SECTION;int main()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // insert null deptno = 55; strcpy(dname,"YIZHEN"); strcpy(loc,"YIZHEN"); loc_ind=-1; EXEC SQL insert into test(deptno,dname,loc) values (:deptno,:dname,:loc:loc_ind); if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; // select null EXEC SQL select deptno,dname,loc into :deptno2,:dname2,:loc2:loc2_ind from test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; if(loc2_ind == -1) &#123; strcpy(loc2,"null"); &#125; printf("select ok...\n"); printf("deptno=%d, dname=%s,loc=%s\n",deptno2,dname2,loc2); EXEC SQL commit release; return 0;&#125; 4.3 错误处理机制 在使用SQL语句和PRO*C对数据库进行操作时，常常有字段空值，无条件删除，无行返回，数据溢出和截断等现象发生，这种现象可以用sqlca和指示器变量来检测 如果每一次执行sql语句后都要通过sqlca.sqlcode的值来判断是否出错，那么是比较繁琐的，一种简单的方法是通过错误处理机制来实现简化 所有的SQL语句都有可能出错,所以都要加以判断，但每个SQL语句后都加错误判断，太麻烦了，可以用一个函数来进行处理 12void sql_error();EXEC SQL WHENEVER SQLERROR DO sql_error(); 这样当发生sqlca.sqlcode &lt; 0的错误时，程序自动转到sql_error中执行，而sqlcode&gt;0的错误是不会自动转到 sql_error函数执行的 WHENEVER语句的范围：WHENEVER是定义语句，他会自动的检测应用程序中的所有sql语句。当编写Pro*C/C++的时候，WHENEVER应该放在第一条内嵌的sql语句（例如connect）之前。如果程序中有多条的WHENEVER语句，那么只有最近的那一条语句起作用 一个使用错误机制的简单例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb12071@orcl"; int deptno; char dname[20]=&#123;0&#125;; char loc[20]=&#123;0&#125;; int deptno2; char dname2[20]; char loc2[20];EXEC SQL END DECLARE SECTION;// the function prints the error reasonvoid sqlerr()&#123; EXEC SQL WHENEVER SQLERROR CONTINUE; printf("error reason: %.*s\n",sqlca.sqlerrm.sqlerrml,sqlca.sqlerrm.sqlerrmc); EXEC SQL rollback work release; exit(-1);&#125;// the function prints the error sqlvoid sqlerr2()&#123; char stm[120]; size_t sqlfc, stmlen=120; unsigned int ret = 0; EXEC SQL WHENEVER SQLERROR CONTINUE; ret = sqlgls(stm, &amp;stmlen, &amp;sqlfc); /* if (ret != 0) &#123; printf("func sqlgls() err, %d \n", ret); return ; &#125;*/ printf("出错的SQL:%.*s\n", stmlen, stm); printf("出错原因:%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); //printf("出错原因:%.70s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); EXEC SQL ROLLBACK WORK RELEASE; exit(-1);&#125;// ======================== connect ======================== //int main()&#123; printf("serversid: %s\n",serversid); // EXEC SQL WHENEVER SQLERROR DO sqlerr(); EXEC SQL WHENEVER SQLERROR DO sqlerr2(); EXEC SQL connect :serversid; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125; 4.4 sqlca通信区 通信区：为了取得每个sql语句执行后的相关状态说明，以便进行错误的后续操作或跟踪 oracle中提供了两个通信区 SQL通信区：sqlca Oracle通信区：oraca sqlca通信区 执行proc程序时，oracle把每一条sql中状态信息存入sqlca中，包括错误代码、警告标志设置、诊断文本和处理行数等 本质上，sqlca是一个结构体 proc每执行一条sql语句，都会把相关信息写入到sqlca，覆盖上一条sql语句的执行的结果信息，所以需要获取执行结果信息的话，要执行完马上获取 oraca通信区 一个类似于sqlca的结构，可以作为sqlca通信区的补充。当需要获取更为详细的状态信息，可以使用oraca oraca通信区对sqlca的补充 可以使用oraca获取执行的sql语句的文本 4.5 宿主数组操作数据 我们可以批量的插入数据和批量的查找数据，这个时候单个变量不足以存储查询到的数据，因此我们需要使用数组 查询数据的时候，sql语句返回的成功执行的条数放入变量 count = sqlca.sqlerrd[2]中 插入的时候，记得在insert语句前面加上for :count 几个注意点： Pro*C不支持数组指针 Pro*C所支持数组最大维数是32767，超出此限制将报错 在SQL语句中使用数组变量，只需给出：和变量名称，不要给下标 示例 123456EXEC SQL BEGIN DECLARE SECTION; int emp_number[100]; char emp_name[100][15];EXEC SQL END DECLARE SECTION;EXEC SQL SELECT number,name INTO :emp_number, :emp_name FROM emp; 一个综合使用的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb1207@orcl"; int deptno; char dname[20]=&#123;0&#125;; char loc[20]=&#123;0&#125;; int deptno2[100]; varchar dname2[100][20]; varchar loc2[100][20]; short loc2_ind[100]; int count;EXEC SQL END DECLARE SECTION;// the function prints the error sqlvoid sqlerr2()&#123; char stm[120]; size_t sqlfc, stmlen=120; unsigned int ret = 0; EXEC SQL WHENEVER SQLERROR CONTINUE; ret = sqlgls(stm, &amp;stmlen, &amp;sqlfc); /* if (ret != 0) &#123; printf("func sqlgls() err, %d \n", ret); return ; &#125;*/ printf("出错的SQL:%.*s\n", stmlen, stm); printf("出错原因:%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); //printf("出错原因:%.70s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); EXEC SQL ROLLBACK WORK RELEASE; exit(-1);&#125;int main()&#123; //struct sqlca sqlca; // must have printf("serversid: %s\n",serversid); int i; EXEC SQL WHENEVER SQLERROR DO sqlerr2(); // connect EXEC SQL connect :serversid; // select EXEC SQL select deptno,dname,loc into :deptno2,:dname2,:loc2:loc2_ind from test; count = sqlca.sqlerrd[2]; printf("count = %d\n",count); for(i=0;i&lt;count;i++) &#123; printf("deptno=%d, dname=%s,loc=%s\n",deptno2[i],dname2[i].arr,loc2[i].arr); &#125; // insert EXEC SQL create table test1 as select * from test where 1=2; // create table EXEC SQL for:count insert into test1 values (:deptno2,:dname2,:loc2:loc2_ind); EXEC SQL commit; printf("select,insert ok...\n"); //printf("deptno=%d, dname=%s,loc=%s\n",deptno2,dname2,loc2); EXEC SQL commit release; return 0;&#125; 4.6 关于Proc、宿主变量、指示变量、数组变量、通信区sqlca，oraca 一个比较好的网页链接：Proc、宿主变量、指示变量、数组变量、通信区 如果网页打不开，点击链接：https://pan.baidu.com/s/1hFDIuwKGVBgpjr_N82x_jw 密码：gw1e 5. 游标5.1 普通游标 使用宿主数组操作数据既有好处，也有坏处。当数据量很小的时候，很方便，但是当数据量很大的时候，不太合适。这时候可以使用游标 游标是为某一次查询而生的，也就是说游标是为了select语句而生，一定和某一条select语句相关联 普通游标只可以往后一直走 遍历右边的时候如何判断访问结束？？ sqlca.sqlcode=100 (ansi组织标准) || sqlca.sqlcode=1403(oracle标准) 补充：使用varchar和使用自定义的char数组的区别 使用varchar，如果第一次读取的时候，字符串长度为20，第二次读取的时候字符串长度为10（假设第一次使用完后没有memset），那么第二次输出的是第二次读取的10字节+第一次读取的10个字节 使用自定义的char数组并且在宿主变量中使用EXEC TYPE自动转换为string类型，那么不会出现上述的问题 操作游标有由 4 条命令： （1） DECLARE CURSOR； （2） OPEN CURSOR； （3） FETCH； （4） CLOSE CURSOR 一个综合使用的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include "sqlca.h"void sqlerr();//连接数据// create table dept2 as select * from dept where 1=2 typedef char dnameType[20];typedef char locType[20];//先定义宿主变量 (SQL变量)EXEC SQL BEGIN DECLARE SECTION ; char * serverid = "xiangbin/xb1207@orcl"; int deptid; char DNAME[32]; char LOC[32]; int count; int deptno2; varchar dname2[20]; //proc编译器 对这个数据类型进行 转换 varchar loc2[20]; short loc_ind2; EXEC SQL TYPE dnameType is string(20); EXEC SQL TYPE locType is string(20); int deptno3; dnameType dname3; //proc编译器 对这个数据类型进行 转换 locType loc3; short loc_ind3;EXEC SQL END DECLARE SECTION ;int main_varchar()&#123; int ret = 0, i = 0; printf("serverid:%s \n", serverid); // 做一个错误处理函数 EXEC SQL WHENEVER SQLERROR DO sqlerr(); EXEC SQL connect :serverid; //1. 定义游标 EXEC SQL DECLARE c CURSOR FOR select deptno, dname, loc from dept; //2. 打开游标 EXEC SQL OPEN c ; // (Open cursor: put the select results into a memory place, // and the cursor pointer points to the first row data.) while(1) &#123; //3. 提取数据 fetch into memset(dname2.arr, 0, 20); memset(loc2.arr, 0, 20); EXEC SQL FETCH c INTO :deptno2, :dname2, :loc2:loc_ind2; if (sqlca.sqlcode == 100 || sqlca.sqlcode == 1403) &#123; break; //访问结束 &#125; if (loc_ind2 == -1) &#123; strcpy(loc2.arr, "NULL"); &#125; printf("%d\t%s\t%s\n ", deptno2, dname2.arr, loc2.arr); &#125; //4. 关闭游标 EXEC SQL CLOSE c; EXEC SQL COMMIT RELEASE; //提交事务断开连接 return ret;&#125;int main()&#123; int ret = 0, i = 0; printf("serverid:%s \n", serverid); //做一个错误处理函数 EXEC SQL WHENEVER SQLERROR DO sqlerr(); EXEC SQL connect :serverid; //1。定义游标 EXEC SQL DECLARE c CURSOR FOR select deptno, dname, loc from dept; //2. 打开游标 EXEC SQL OPEN c ; while(1) &#123; //3. 提取数据 fetch into //memset(dname2.arr, 0, 20); //memset(loc2.arr, 0, 20); EXEC SQL FETCH c INTO :deptno3, :dname3, :loc3:loc_ind3; if (sqlca.sqlcode == 100 || sqlca.sqlcode == 1403) &#123; break; //访问结束 &#125; if (loc_ind3 == -1) &#123; strcpy(loc3, "NULL"); &#125; printf("%d\t%s\t%s\n ", deptno3, dname3, loc3); &#125; //4. EXEC SQL CLOSE c; EXEC SQL COMMIT RELEASE; //提交事务断开连接 return ret; &#125; 5.2 滚动游标 区别于普通游标，可以往任何位置走 一个简单的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include "sqlca.h"//演示滚动游标查询数据extern sqlgls(char * , size_t *, size_t * );extern sqlglmt(void *,char *,size_t *,size_t *);void connet();void sqlerr02();void sqlerr02()&#123; char stm[120]; size_t sqlfc, stmlen=120; unsigned int ret = 0; //出错时,可以把错误SQL语言给打印出来 EXEC SQL WHENEVER SQLERROR CONTINUE; ret = sqlgls(stm, &amp;stmlen, &amp;sqlfc); printf("出错的SQL:%.*s\n", stmlen, stm); printf("出错原因:%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc); EXEC SQL ROLLBACK WORK RELEASE; exit(1);&#125;void nodata()&#123; int ret = 0; printf("没有发现数据\n"); if (sqlca.sqlcode != 0) &#123; ret = sqlca.sqlcode; printf("sqlca.sqlcode: err:%d \n", sqlca.sqlcode); return ; &#125;&#125;typedef char dnameType[20];typedef char locType[20];EXEC SQL BEGIN DECLARE SECTION; EXEC SQL TYPE dnameType is string(20); EXEC SQL TYPE locType is string(20); char *usrname = "scott"; char *passwd = "tiger"; char *serverid = "orcl"; int deptno; dnameType dname; //string 数据类型 short dname_ind; locType loc; short loc_ind; EXEC SQL END DECLARE SECTION;int main()&#123; int ret = 0; int i = 0; EXEC SQL WHENEVER SQLERROR DO sqlerr02(); connet(); //EXEC SQL WHENEVER NOT FOUND DO nodata(); //1 定义游标 declare cursor 在为某一次查询 EXEC SQL DECLARE c SCROLL CURSOR FOR select deptno, dname, loc from dept; //2 打开游标 open cursor EXEC SQL OPEN c; //EXEC SQL WHENEVER NOT FOUND DO break; //3 获取数据 fetch data // 3.1 查询最后一条数据 EXEC SQL FETCH LAST c INTO :deptno, :dname:dname_ind, :loc:loc_ind; //printf("条目数:%d\t", sqlca.sqlerrd[2]); printf("%d\t %s\t %s \n", deptno, dname, loc ); // 3.2 查询第一条数据 EXEC SQL FETCH FIRST c INTO :deptno, :dname:dname_ind, :loc:loc_ind; printf("%d\t %s\t %s \n", deptno, dname, loc ); // 3.3 查询第2条数据 EXEC SQL FETCH ABSOLUTE 2 c INTO :deptno, :dname:dname_ind, :loc:loc_ind; printf("%d\t %s\t %s \n", deptno, dname, loc ); // 3.4 查询相对第2条数据 也就是第4条 EXEC SQL FETCH RELATIVE 2 c INTO :deptno, :dname:dname_ind, :loc:loc_ind; printf("%d\t %s\t %s \n", deptno, dname, loc ); // 3.5 查询下一条 EXEC SQL FETCH NEXT c INTO :deptno, :dname:dname_ind, :loc:loc_ind; printf("%d\t %s\t %s \n", deptno, dname, loc ); // 3.6 查询前一条 EXEC SQL FETCH PRIOR c INTO :deptno, :dname:dname_ind, :loc:loc_ind; printf("%d\t %s\t %s \n", deptno, dname, loc ); //4 关闭游标 close data EXEC SQL CLOSE c; EXEC SQL COMMIT WORK RELEASE; printf("return ok...\n"); return ret ;&#125;void connet()&#123; int ret = 0; //连接数据库 EXEC SQL CONNECT:usrname IDENTIFIED BY:passwd USING:serverid ; if (sqlca.sqlcode != 0) &#123; ret = sqlca.sqlcode; printf("sqlca.sqlcode: err:%d \n", sqlca.sqlcode); return ; &#125; else &#123; printf("connect ok...\n"); &#125;&#125; 6. 动态SQL 输入sql语句，动态查询结果，类似sqlplus客户端 相当于自己再次实现一个oracle api接口 ansi方式 比oracle方式简单一点 不需要自己打造输入输出缓冲区 oracle方式 自己打造输入输出缓冲区 oracle数据类型的转换]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Pro*C</tag>
        <tag>嵌入式SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库的使用]]></title>
    <url>%2F2018%2F07%2F03%2F005oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Oracle数据的安装1.1 Windows下虚拟机环境+Oracle数据库的安装 网上教程很多，这里学习的话推荐按照这篇博客搭建：15分钟搭建Linux操作系统+Oracle数据库的环境 如果连接丢失了，请移步网盘链接：https://pan.baidu.com/s/1UAY-V0TidR0su9-tuw6CDQ 密码：i2wo 1.2 Mac下虚拟机环境+Oracle数据库的安装 上述搭建过程在Mac下要注意一点，那就是安装完成虚拟机之后，发现上面没有管理这个菜单栏，那么如何导入虚拟机文件么？ 双击.ova文件即可 2.Oracle数据库的基本概念2.1一个 Oracle 服务器 是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理 由一个Oracle 实例 和一个 Oracle 数据库组成 Oracle 数据库: 位于硬盘上实际存放数据的文件, 这些文件组织在一起, 成为一个逻辑整体, 即为 Oracle 数据库。 因此在 Oracle 看来, “数据库” 是指硬盘上文件的逻辑集合, 必须要与内存里实例合作, 才能对外提供数据管理服务。 Oracle 实例: 位于物理内存里的数据结构. 它由一个共享的内存池和多个后台进程所组成, 共享的内存池可以被所有进程访问。 用户如果要存取数据库(也就是硬盘上的文件) 里的数据, 必须通过实例才能实现, 不能直接读取硬盘上的文件。 2.2 Oracle数据库的结构 2.3 管理机制 oracle：基于用户的管理机制 创建一个信息系统, 给你分配一个用户, 创建表空间 ..创建表.. mysql：基于数据库的管理机制 创建一个信息系统,创建一个数据库 3.基本的select语句3.1 简单使用规则12SELECT *|&#123;[DISTINCT] column|expression [alias],...&#125;FROM table; 说明 SQL 语言大小写不敏感 SQL 可以写在一行或者多行 关键字（例如select）不能被缩写也不能分行 各子句一般要分行写 使用缩进提高语句的可读性 总结 select后面可以是属性列 12SELECT last_name, salaryFROM employees; select后面可以是表达式 12SELECT last_name, salary, salary + 300FROM employees; select后面可以是函数 3.2 列的别名 重命名一个列 便于计算 紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写 AS可以省略；当别名没有空格的时候，双引号可以省略 12345SELECT last_name "Name", salary*12 "Annual Salary"FROM employees;SELECT last_name AS name, commission_pct commFROM employees; -- 省略双引号，省略as 3.3 连接符 把列与列，列与字符连接在一起 用 ‘||’表示 可以用来‘合成’列 12SELECT last_name||job_id AS "Employees"FROM employees; 3.4 字符串 字符串可以是 SELECT 列表中的一个字符,数字,日期 日期和字符只能在单引号中出现（单引号，单引号，单引号） 每当返回一行时，字符串被输出一次 123SELECT last_name ||' is a '||job_id AS "Employee Details"FROM employees; 3.5 捣蛋鬼NULL 空值是无效的，未指定的，未知的或不可预知的值 空值不是空格或者0 注意点： 任何表达式和null运算都为空 null != null （查询不为空的时候，使用的是 xx is not null ，而不是 xx !=null） 4. 过滤和排序4.1 过滤 使用where语句，将不满足条件的语句过滤掉 where 子句紧随 from 子句 between: 来显示在一个区间内的值(包含两端) in: 显示列表中的值 like: 模糊查询 % 代表零个或多个字符(任意个字符) _代表一个字符 123SELECT *|&#123;[DISTINCT] column|expression [alias],...&#125;FROM table[WHERE condition(s)]; 4.2 字符和日期 字符和日期要包含在单引号中（单引号，单引号，单引号） 字符大小写敏感，日期格式敏感 默认的日期格式是 DD-MON-RR 4.3 排序 使用 ORDER BY 子句排序 ASC（ascend）: 升序 DESC（descend）: 降序 排序的规则 可以按照select语句中的列名排序 可以按照别名列名排序 可以按照select语句中的列名的顺序值排序 如果要按照多列进行排序，则规则是先按照第一列排序，如果相同，则按照第二列排序；以此类推 Desc: 5 单行函数5.1 SQL函数 SQL 函数 注意：函数可以没有参数，但必须要有返回值 两种 SQL 函数 5.2单行函数 操作数据对象 接受参数返回一个结果 只对一行进行变换 每行返回一个结果 可以转换数据类型 可以嵌套 参数可以是一列或一个值 6.分组函数6.1 什么是分组函数 分组函数作用于一组数据，并对一组数据返回一个值。 AVG COUNT MAX MIN SUM 12345SELECT [column,] group_function(column), ...FROM table[WHERE condition][GROUP BY column][ORDER BY column]; 6.2 GROUP BY 子句 在SELECT 列表中所有未包含在组函数中的列都应该包含在 GROUP BY 子句中 包含在 GROUP BY 子句中的列不必包含在SELECT 列表中 不能在 WHERE 子句中使用组函数（注意） 可以在 HAVING 子句中使用组函数]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-其他：顺时针旋转矩阵]]></title>
    <url>%2F2018%2F01%2F18%2F004%E5%85%B6%E4%BB%96%EF%BC%8C%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1.题目描述 有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。 给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于300。 测试样例：[[1,2,3],[4,5,6],[7,8,9]],3 返回：[[7,4,1],[8,5,2],[9,6,3]] 2.代码编写 提交代码 1234567891011121314151617181920212223242526/***************** * 思想： * 在旋转的时候，我们应该一行一行或者一列一列的来考虑 * 如果按照一行一行来考虑，那么: * 原矩阵的第一行会变成最后一列 * 第二行会变成倒数第二列 * ......................**********************/class Rotate &#123;public: vector&lt;vector&lt;int&gt; &gt; rotateMatrix(vector&lt;vector&lt;int&gt; &gt; mat, int n) &#123; // write code here vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n)); int k = n - 1; // 从最后一列开始，然后倒数第二列，倒数第三列 // 按行遍历原数组：mat for (vector&lt;vector&lt;int&gt; &gt;::iterator p = mat.begin(); p != mat.end();++p) &#123; for (int i = 0; i &lt; n; i++) &#123; res[i][k] = (*p)[i]; // p是一个指针，指向的是一个“街区” &#125; k--; &#125;// end for return res; &#125;&#125;; 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/***************** * 思想： * 在旋转的时候，我们应该一行一行或者一列一列的来考虑 * 如果按照一行一行来考虑，那么: * 原矩阵的第一行会变成最后一列 * 第二行会变成倒数第二列 * ..............**********************/class Rotate &#123;public: vector&lt;vector&lt;int&gt; &gt; rotateMatrix(vector&lt;vector&lt;int&gt; &gt; mat, int n) &#123; // write code here vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n)); int k = n - 1; // 从最后一列开始，然后倒数第二列，倒数第三列 // 按行遍历原数组：mat for (vector&lt;vector&lt;int&gt; &gt;::iterator p = mat.begin(); p != mat.end();++p) &#123; for (int i = 0; i &lt; n; i++) &#123; res[i][k] = (*p)[i]; // p是一个指针，指向的是一个“街区” &#125; k--; &#125;// end for return res; &#125;&#125;;// ===================== 测试代码 ======================== //void print(vector&lt;vector&lt;int&gt; &gt; &amp;mat, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; mat[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; vector&lt;vector&lt;int&gt; &gt; mat(&#123; &#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125; &#125;); int n = 3; cout &lt;&lt; "before:" &lt;&lt; endl; print(mat, 3); Rotate r; vector&lt;vector&lt;int&gt; &gt; res = r.rotateMatrix(mat, n); cout &lt;&lt; "after:" &lt;&lt; endl; print(res, 3); return 0;&#125; 3.小结 讨论区有人提出可以找规律，直接使用mat[i][j]被旋转到了mat[j][n-i-1]的位置 脑子果然是个好东西，以后一定要好好用用]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>简单编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-去哪儿：字符串替换]]></title>
    <url>%2F2018%2F01%2F17%2F003%E5%8E%BB%E5%93%AA%E5%84%BF%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1.题目描述 请你实现一个简单的字符串替换函数。原串中需要替换的占位符为”%s”,请按照参数列表的顺序一一替换占位符。若参数列表的字符数大于占位符个数。则将剩下的参数字符添加到字符串的结尾。 给定一个字符串A，同时给定它的长度n及参数字符数组arg，请返回替换后的字符串。保证参数个数大于等于占位符个数。保证原串由大小写英文字母组成，同时长度小于等于500。 测试样例：&quot;A%sC%sE&quot;,7,[&#39;B&#39;,&#39;D&#39;,&#39;F&#39;] 返回：&quot;ABCDEF&quot; 2.代码编写123456789101112131415161718192021222324252627282930313233/********************************************* 思路：* 使用两个指针，分别一前一后；* 如果这两个指针下的值恰好对应为%s，那么替换*********************************************/class StringFormat &#123;public: string formatString(string A, int n, vector&lt;char&gt; arg, int m) &#123; // write code here char buf[505] = &#123;0&#125;; // 最终的结果存储数组 int i = 0, j = 0; // 循环变量 int pre = 0, cur=1; // 指针循环变量 while (pre &lt; n) &#123; if (A[pre] == '%' &amp;&amp; cur&lt;n &amp;&amp; A[cur] == 's') &#123; buf[i++] = arg[j++]; pre += 2; cur += 2; &#125; else &#123; buf[i++] = A[pre]; ++pre; ++cur; &#125; &#125; // end while // 如果vector中参数多了，那么添加在最后 while (j &lt; arg.size()) &#123; buf[i++] = arg[j++]; &#125; return string(buf); &#125;&#125;; 3.小结 其实一开始的想法是直接查找”%s”的位置，然后字符串替换 但是后来想到可以用指针的形式练习一下，所以最后就用指针的方式做了 看了一下大家讨论的结果 有人提出把”%s”最为分割符，分割出数组，然后在连接起来，感觉很不错的样子 还有人提出利用正则表达式，厉害]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-京东：抛小球]]></title>
    <url>%2F2018%2F01%2F17%2F002%E4%BA%AC%E4%B8%9C%EF%BC%8C%E6%8A%9B%E5%B0%8F%E7%90%83%2F</url>
    <content type="text"><![CDATA[1.题目描述 小东和三个朋友一起在楼上抛小球，他们站在楼房的不同层，假设小东站的楼层距离地面N米，球从他手里自由落下，每次落地后反跳回上次下落高度的一半，并以此类推知道全部落到地面不跳，求4个小球一共经过了多少米？(数字都为整数)给定四个整数A,B,C,D，请返回所求结果。 测试样例：100,90,80,70 结果：1020 2.代码编写12345678910111213141516171819202122232425class Balls &#123;public: int calcDistance(int A, int B, int C, int D) &#123; // write code here return getHeight(A) + getHeight(B) + getHeight(C) + getHeight(D); &#125;private: int getHeight(float h)&#123; float sum = h; // 第一次降落 while(h &gt; 0.0001)&#123; // 只要是从高度大于0的地方降落，都会回弹降落高度的一半 h = h/2; // 回弹到原来高度的一半 sum += 2*h; // 再一次落地时，其实包含上去和下来 &#125; // return sum; // 题目要求最后的结果为整数，那么只有两种处理方式 // 1)：舍去多余的部分 2)：结果+0.5取整数 /***************************************** 函数名: ceil 用 法: double ceil(double x); 功 能: 返回大于或者等于指定表达式的最小整数 ******************************************/ return ceil(sum); &#125; &#125;; 3.小结 我认为这道题目考察的是对整数的处理，也就是说，不可以直接使用int型的高度 但是看到讨论区别人的代码后，感觉思路开阔了很多，有人指出，这就是等比数列求极限 以下是等比数列求极限思想代码 12345678class Balls &#123;public: int calcDistance(int A, int B, int C, int D) &#123; // write code here return 3*(A+B+C+D); &#125;&#125;;]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组类型，指针数组类型以及数组类型的指针]]></title>
    <url>%2F2018%2F01%2F16%2F001%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[C/C++中有数组类型，指针数组，数组类型的指针，有人称之为压死C语言初学者的三座大山，那么如何区分呢？ 1.数组类型12345678910111213141516171819202122232425#include &lt;stdio.h&gt;// 数组类型int main()&#123; // int a[10]; // 这是我们常用的定义数组的方式 // 定义一个数组类型 int[10] typedef int(MyArrayType)[10]; // 注意，这里MyArrayType就是一个数组类型，这个数组类型大小为10个int类型的内存大小 MyArrayType a; // 相当于int a[10]; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; a[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("a[i] = %d\n", i, a[i]); &#125; return 0;&#125; 2.指针数组1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;// 指针数组类型int main()&#123; // 定义一个指向大小为10个int类型内存的指针数组类型 typedef int(*pMyArrayType)[10]; int a[10]; pMyArrayType p = &amp;a; // 这里为什么要对a取地址，想想？？ easy // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*p)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("p[%d] = %d\t", i, (*p)[i]); printf("a[%d] = %d\n", i, a[i]); &#125; return 0;&#125; 3.数组类型的指针1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;// 数组类型的指针int main()&#123; // 1.我们可以定义一个数组类型，然后用这个类型来定义数组类型的指针 // 定义一个数组类型 int[10] typedef int(MyArrayType)[10]; // 注意，这里MyArrayType就是一个数组类型，这个数组类型大小为10个int类型的内存大小 MyArrayType* p; int a[10]; p = &amp;a; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*p)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("p[%d] = %d\t", i, (*p)[i]); printf("a[%d] = %d\n", i, a[i]); &#125; printf("-----------------------------------------------------------\n"); // 2.直接定义 int(*pArr)[10]; // 注意，这里的pArr是变量的名字，不是类型，不可以用来定义新的变量 int b[10]; pArr = &amp;b; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*pArr)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("pArr[%d] = %d\t", i, (*pArr)[i]); printf("b[%d] = %d\n", i, b[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++难点</tag>
      </tags>
  </entry>
</search>
