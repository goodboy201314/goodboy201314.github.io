<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2016校招真题-其他：顺时针旋转矩阵]]></title>
    <url>%2F2018%2F01%2F18%2F004%E5%85%B6%E4%BB%96%EF%BC%8C%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1.题目描述 有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。 给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于300。 测试样例：[[1,2,3],[4,5,6],[7,8,9]],3 返回：[[7,4,1],[8,5,2],[9,6,3]] 2.代码编写 提交代码 1234567891011121314151617181920212223242526/***************** * 思想： * 在旋转的时候，我们应该一行一行或者一列一列的来考虑 * 如果按照一行一行来考虑，那么: * 原矩阵的第一行会变成最后一列 * 第二行会变成倒数第二列 * ......................**********************/class Rotate &#123;public: vector&lt;vector&lt;int&gt; &gt; rotateMatrix(vector&lt;vector&lt;int&gt; &gt; mat, int n) &#123; // write code here vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n)); int k = n - 1; // 从最后一列开始，然后倒数第二列，倒数第三列 // 按行遍历原数组：mat for (vector&lt;vector&lt;int&gt; &gt;::iterator p = mat.begin(); p != mat.end();++p) &#123; for (int i = 0; i &lt; n; i++) &#123; res[i][k] = (*p)[i]; // p是一个指针，指向的是一个“街区” &#125; k--; &#125;// end for return res; &#125;&#125;; 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/***************** * 思想： * 在旋转的时候，我们应该一行一行或者一列一列的来考虑 * 如果按照一行一行来考虑，那么: * 原矩阵的第一行会变成最后一列 * 第二行会变成倒数第二列 * ..............**********************/class Rotate &#123;public: vector&lt;vector&lt;int&gt; &gt; rotateMatrix(vector&lt;vector&lt;int&gt; &gt; mat, int n) &#123; // write code here vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n)); int k = n - 1; // 从最后一列开始，然后倒数第二列，倒数第三列 // 按行遍历原数组：mat for (vector&lt;vector&lt;int&gt; &gt;::iterator p = mat.begin(); p != mat.end();++p) &#123; for (int i = 0; i &lt; n; i++) &#123; res[i][k] = (*p)[i]; // p是一个指针，指向的是一个“街区” &#125; k--; &#125;// end for return res; &#125;&#125;;// ===================== 测试代码 ======================== //void print(vector&lt;vector&lt;int&gt; &gt; &amp;mat, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; mat[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; vector&lt;vector&lt;int&gt; &gt; mat(&#123; &#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125; &#125;); int n = 3; cout &lt;&lt; "before:" &lt;&lt; endl; print(mat, 3); Rotate r; vector&lt;vector&lt;int&gt; &gt; res = r.rotateMatrix(mat, n); cout &lt;&lt; "after:" &lt;&lt; endl; print(res, 3); return 0;&#125; 3.小结]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>简单编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-去哪儿：字符串替换]]></title>
    <url>%2F2018%2F01%2F17%2F003%E5%8E%BB%E5%93%AA%E5%84%BF%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1.题目描述 请你实现一个简单的字符串替换函数。原串中需要替换的占位符为”%s”,请按照参数列表的顺序一一替换占位符。若参数列表的字符数大于占位符个数。则将剩下的参数字符添加到字符串的结尾。 给定一个字符串A，同时给定它的长度n及参数字符数组arg，请返回替换后的字符串。保证参数个数大于等于占位符个数。保证原串由大小写英文字母组成，同时长度小于等于500。 测试样例：&quot;A%sC%sE&quot;,7,[&#39;B&#39;,&#39;D&#39;,&#39;F&#39;] 返回：&quot;ABCDEF&quot; 2.代码编写123456789101112131415161718192021222324252627282930313233/********************************************* 思路：* 使用两个指针，分别一前一后；* 如果这两个指针下的值恰好对应为%s，那么替换*********************************************/class StringFormat &#123;public: string formatString(string A, int n, vector&lt;char&gt; arg, int m) &#123; // write code here char buf[505] = &#123;0&#125;; // 最终的结果存储数组 int i = 0, j = 0; // 循环变量 int pre = 0, cur=1; // 指针循环变量 while (pre &lt; n) &#123; if (A[pre] == '%' &amp;&amp; cur&lt;n &amp;&amp; A[cur] == 's') &#123; buf[i++] = arg[j++]; pre += 2; cur += 2; &#125; else &#123; buf[i++] = A[pre]; ++pre; ++cur; &#125; &#125; // end while // 如果vector中参数多了，那么添加在最后 while (j &lt; arg.size()) &#123; buf[i++] = arg[j++]; &#125; return string(buf); &#125;&#125;; 3.小结 其实一开始的想法是直接查找”%s”的位置，然后字符串替换 但是后来想到可以用指针的形式练习一下，所以最后就用指针的方式做了 看了一下大家讨论的结果 有人提出把”%s”最为分割符，分割出数组，然后在连接起来，感觉很不错的样子 还有人提出利用正则表达式，厉害]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-京东：抛小球]]></title>
    <url>%2F2018%2F01%2F17%2F002%E4%BA%AC%E4%B8%9C%EF%BC%8C%E6%8A%9B%E5%B0%8F%E7%90%83%2F</url>
    <content type="text"><![CDATA[1.题目描述 小东和三个朋友一起在楼上抛小球，他们站在楼房的不同层，假设小东站的楼层距离地面N米，球从他手里自由落下，每次落地后反跳回上次下落高度的一半，并以此类推知道全部落到地面不跳，求4个小球一共经过了多少米？(数字都为整数)给定四个整数A,B,C,D，请返回所求结果。 测试样例：100,90,80,70 结果：1020 2.代码编写12345678910111213141516171819202122232425class Balls &#123;public: int calcDistance(int A, int B, int C, int D) &#123; // write code here return getHeight(A) + getHeight(B) + getHeight(C) + getHeight(D); &#125;private: int getHeight(float h)&#123; float sum = h; // 第一次降落 while(h &gt; 0.0001)&#123; // 只要是从高度大于0的地方降落，都会回弹降落高度的一半 h = h/2; // 回弹到原来高度的一半 sum += 2*h; // 再一次落地时，其实包含上去和下来 &#125; // return sum; // 题目要求最后的结果为整数，那么只有两种处理方式 // 1)：舍去多余的部分 2)：结果+0.5取整数 /***************************************** 函数名: ceil 用 法: double ceil(double x); 功 能: 返回大于或者等于指定表达式的最小整数 ******************************************/ return ceil(sum); &#125; &#125;; 3.小结 我认为这道题目考察的是对整数的处理，也就是说，不可以直接使用int型的高度 但是看到讨论区别人的代码后，感觉思路开阔了很多，有人指出，这就是等比数列求极限 以下是等比数列求极限思想代码 12345678class Balls &#123;public: int calcDistance(int A, int B, int C, int D) &#123; // write code here return 3*(A+B+C+D); &#125;&#125;;]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组类型，指针数组类型以及数组类型的指针]]></title>
    <url>%2F2018%2F01%2F16%2F001%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[C/C++中有数组类型，指针数组，数组类型的指针，有人称之为压死C语言初学者的三座大山，那么如何区分呢？ 1.数组类型12345678910111213141516171819202122232425#include &lt;stdio.h&gt;// 数组类型int main()&#123; // int a[10]; // 这是我们常用的定义数组的方式 // 定义一个数组类型 int[10] typedef int(MyArrayType)[10]; // 注意，这里MyArrayType就是一个数组类型，这个数组类型大小为10个int类型的内存大小 MyArrayType a; // 相当于int a[10]; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; a[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("a[i] = %d\n", i, a[i]); &#125; return 0;&#125; 2.指针数组1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;// 指针数组类型int main()&#123; // 定义一个指向大小为10个int类型内存的指针数组类型 typedef int(*pMyArrayType)[10]; int a[10]; pMyArrayType p = &amp;a; // 这里为什么要对a取地址，想想？？ easy // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*p)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("p[%d] = %d\t", i, (*p)[i]); printf("a[%d] = %d\n", i, a[i]); &#125; return 0;&#125; 3.数组类型的指针1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;// 数组类型的指针int main()&#123; // 1.我们可以定义一个数组类型，然后用这个类型来定义数组类型的指针 // 定义一个数组类型 int[10] typedef int(MyArrayType)[10]; // 注意，这里MyArrayType就是一个数组类型，这个数组类型大小为10个int类型的内存大小 MyArrayType* p; int a[10]; p = &amp;a; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*p)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("p[%d] = %d\t", i, (*p)[i]); printf("a[%d] = %d\n", i, a[i]); &#125; printf("-----------------------------------------------------------\n"); // 2.直接定义 int(*pArr)[10]; // 注意，这里的pArr是变量的名字，不是类型，不可以用来定义新的变量 int b[10]; pArr = &amp;b; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*pArr)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("pArr[%d] = %d\t", i, (*pArr)[i]); printf("b[%d] = %d\n", i, b[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++难点</tag>
      </tags>
  </entry>
</search>
