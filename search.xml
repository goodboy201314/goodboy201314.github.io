<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Oracle Pro*C 编程入门]]></title>
    <url>%2F2018%2F07%2F05%2F006Oracle-Pro-C-%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. 概念1.1 什么是Pro*c程序 在oracle数据库管理系统中，有三种访问数据库的方法： 1.用 SQL*Plus，直接输入sql命令以命令行交换的方式访问数据库 2.用一些应用开发工具来访问数据库(PL/SQL developer) 3.利用在语言内嵌入sql语言或者调用oracle库函数来访问数据库，例如Pro*c Pro*C把过程化语言c和非过程化语言sql最完善的结合起来，具有完备的过程处理能力，又能完成任何数据库的处理任务，使用户可以通过编程完成各种类型的报表。 在Pro*C程序中嵌入sql语言，利用这些sql语言可以完成动态地建立、修改和删除数据库中的表，也可以查询、插入、修改和删除数据库表中的行，还可以实现事务的提交和回滚。 一句话，通过在过程化编程语言C/C++中嵌入SQL语句而开发出的应用程序 补充1：什么是嵌入式SQL？ 在通用编程语言中使用的SQL称为嵌入式SQL 在SQL标准中定义了多种语言的嵌入式SQL 各个厂商对嵌入式SQL的具体实现不同 补充2：什么是宿主语言？ 嵌入式SQL的载体是宿主语言 1.2 Oracle 预编译器 功能：完成Pro*C源程序到纯C源程序的转换 Pro*c/c++应用程序完整开发流程 普通c程序: C源文件(.c) -&gt; 目标文件(.o) -&gt; 可执行文件 Pro*c/c++程序: Pro*C 源文件(.pc) -&gt; C源文件(.c) -&gt; 目标文件(.o) -&gt; 可执行文件 基本命令格式(.pc -&gt; .c/.cc) 1234567891011121314151617proc iname=filename [OptionName1=value1]…[OptionNameN=valueN]1.常用编译选项: INAME=path and filename (name of the input file) 1.pc ONAME=path and filename (name of the output file) 1.c 1.cc INCLUDE=path (头文件所在路径） --INCLUDE =路径名 或 INCLUDE =(路径名1,路径名2) PARSE=FULL | PARTIA | NONE (default FULL for C, Others for C++) CODE=ANSI_C | CPP (default ansi_c) USERID=username/password2.编译1个含有嵌入式SQL的C++ (hello.pc用C++语法写的):parse=none 告诉proc编译器 按照c++规范解析 dm02_hello.pccode=cpp 告诉proc编译器 按照c++规范 生产文件proc hello.pc parse=none code=cpp oname=hello.cc3.编译1个含有嵌入式SQL的C (hello.pc用C语法写的):proc hello.pc 2. Pro*C 语法结构2.1 嵌入 SQL 语句在程序中的标志 嵌入式语句以 EXEC SQL 开头， 以分号结束 2.2 换行 当一行写不下一条嵌入式 SQL 语句时， 可以用反斜线()换行(也可以不用, 但为了程序的可读性好一些， 建议使用) 2.3 程序结构 每一个 Pro*C 程序都包括两部分：（1）应用程序首部；（2）应用程序体 应用程序首部定义了 ORACLE 数据库的有关变量， 为在 C 语言中操纵 ORACLE 数据库做好了准备 应用程序体基本上由 Pro*C 的 SQL 语句调用组成。主要指查询SELECT、INSERT、UPDATE、DELETE 等语句 应用程序的组成结构如图所示: 2.4 大小写 嵌入式语句内不区分大小写 2.5 宿主变量 宿主变量的使用是为了实现 Oracle 数据库和应用程序之间的数据通信 定义: Pro*C 中宿主变量有两种定义方法 ANSI 方法 按照 ANSI 标准， 只有在 Pro*C 预编译程序的宿主变量声明区内声明的变量才能做为宿主变量 宿主变量声明区域为 EXEC SQL BEGIN DECLARE SECTION和 EXEC SQL END DECLARE SECTION 语句之间的区域 Oracle 方法 Oracle 对 ANSI 标准进行了扩充， 它允许在程序中的任何部分声明宿主变量 所以， 当把预编译选项 MODE 设为 ORACLE 时， 应用程序不必在指定的声明区域内声明宿主变量 使用: SQL 语句或 PL/SQL 块参照宿主变量时， 必须在宿主变量名称前加冒号, 以区别于 Oracle 数据库对象名称 但在 C 语句在使用这些变量时， 则不能加冒号 注意： Pro*C 应用程序中不能使用宿主变量提供数据库对象名称， 所以， 在CREATE, ALTER 和 DROP 等 DDL 语句中不能使用输入宿主变量 3. 小试牛刀：Pro*C/C++开发基础3.1 开发流程 编写.pc代码(hello.pc) 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"int main()&#123; printf("ok...\n"); return 0;&#125; 使用proc编译，在当前目录下打开终端，输入 proc hello.pc 使用gcc编译 1.要找到sqlca.h的位置，打开终端输入 find / -name sqlca.h 查询结果为：/u01/app/oracle/product/12.2/db_1/precomp/public/sqlca.h 2.接着，要找到使用的动态库libclntsh.so, 打开终端输入 find / -name libclntsh.so 查询结果为：/u01/app/oracle/product/12.2/db_1/lib/libclntsh.so ok，现在可以编写gcc命令了，在当前目录下打开终端，输入 gcc -o hello hello.c -I/u01/app/oracle/product/12.2/db_1/precomp/public/ -L/u01/app/oracle/product/12.2/db_1/lib/ -lclntsh 运行hello程序， 在当前目录下打开终端，输入 ./hello 如果上述过程没有问题，那么恭喜，整个开发流程没有错误。 这里我实践的时候，报了一堆堆错误，找到第一条后，发现是大致的意思是：proc工具预编译时找不到stddef.h PCC-S-02015, unable to open include file Error at line 15, column 10 in file /usr/include/_G_config.h #include &lt;stddef.h&gt; 解决方法（pcscfg.cfg这个文件配置有错误）： 1.找到文件pcscfg.cfg的位置， find / -name pcscfg.cfg 2.找到stddef.h文件的位置和版本信息， find / -name stddef.h 3.打开1中文件pcscfg.cfg文件，替换stddef.h路径和版本信息 3.2 连接数据库 上述流程全部OK后，我们接着从连接数据库开始，连接数据库有3种方法 12345678-- 方法1EXEC SQL CONNECT :usr_pwd;-- 方法2EXEC SQL CONNECT :username IDENTIFIED BY :password ;-- 方法3/* connect to the nondefault database using db_name */EXEC SQL CONNECT :username IDENTIFIED BY :password AT :db_name USING :db_string; 这里提供一个使用方法1的例子：使用用户名xiangbin，密码xb1207，连接orcl 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb1207@orcl";EXEC SQL END DECLARE SECTION;int main()&#123; printf("serversid: %s\n",serversid); EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit release; printf("connect ok...\n"); return 0;&#125; 几点说明： #include &quot;sqlca.h&quot; 为要包含的头文件 sqlca是一个结构类型的变量，它是oracle和应用程序的一个接口。在执行Pro*C程序时，oracle把每一个嵌入SQL语句执行的状态信息存入SQLCA中，根据这些信息，可判断SQL语句的执行是否成功，处理的行数，错误信息等，结构体组成如下所示： 1234567891011121314151617struct sqlca&#123; char sqlcaid[8]; //标识通讯区 long sqlabc; //通序区的长度 long sqlcode; //最近执行的SQL语句的状态码 struct&#123; unsigned sqlerrml;//信息文本长度 char sqlerrmc[10];//错误正文 &#125;sqlerrm; char sqlerrp[8]; char sqlerrd[6];//当前oracle的状态，sqlerrd[2]才有意义，表示DML语句处理的行数 char sqlwarn[8];//提供可能遇到的条件信息 char sqlext[8];&#125;;struct sqlca sqlca; sqlcode的值如下： 等于0 表示SQL语句被正确执行 大于0 oracle执行了该语句，但遇到一个例外（例如没有找到任何数据） 小于0 表示由于数据库、系统、网络或者应用程序的错误，oracle未执行该语句，当出现这一类错误时，当前事务一般应该回滚。 another example: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char user[20]=&#123;0&#125;; char pwd[20] =&#123;0&#125;; char dbname[20]=&#123;0&#125;;EXEC SQL END DECLARE SECTION;int main()&#123; //printf("serversid: %s\n",serversid); strcpy(user,"xiangbin"); strcpy(pwd,"xb1207"); strcpy(dbname,"orcl"); //EXEC SQL connect :serversid; EXEC SQL CONNECT :user IDENTIFIED BY :pwd USING :dbname; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit release; printf("connect ok...\n"); return 0;&#125; 3.3 数据库的常见操作 - insert、update、delete、select insert、update、delete、select对应的代码分别如下 这里select是简单的使用，只查询1行，详细的使用在第4小结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// 1. include the header file#include "sqlca.h"// 2. declare the parameterEXEC SQL BEGIN DECLARE SECTION; char *serversid = "xiangbin/xb1207@orcl"; int deptno; char dname[20]=&#123;0&#125;; char loc[20]=&#123;0&#125;; int deptno2; char dname2[20]; char loc2[20];EXEC SQL END DECLARE SECTION;// ======================== 1. connect ======================== //int main_coon()&#123; printf("serversid: %s\n",serversid); EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 2. insert ======================== //int main_insert()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // insert deptno = 50; strcpy(dname,"YIZHEN"); strcpy(loc,"YIZHEN"); EXEC SQL insert into test(deptno,dname,loc) values (:deptno,:dname,:loc); if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 3. update ======================== //int main_update()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // insert deptno = 50; printf("Enter the dname:"); scanf("%s",dname); EXEC SQL update test set dname=:dname where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 4. delete ======================== //int main_delete()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // delete deptno = 10; EXEC SQL delete test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("connect ok...\n"); EXEC SQL commit release; return 0;&#125;// ======================== 5. select ======================== //int main()&#123; printf("serversid: %s\n",serversid); // connect EXEC SQL connect :serversid; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; // select deptno = 10; EXEC SQL select deptno,dname,loc into :deptno2,:dname2,:loc2 from test where deptno=:deptno; if(sqlca.sqlcode != 0) &#123; printf("connect error:%d\n",sqlca.sqlcode); return sqlca.sqlcode; &#125; EXEC SQL commit; printf("select ok...\n"); printf("deptno=%d, dname=%s,loc=%s\n",deptno2,dname2,loc2); EXEC SQL commit release; return 0;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>Pro*C</tag>
        <tag>嵌入式SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库的使用]]></title>
    <url>%2F2018%2F07%2F03%2F005oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Oracle数据的安装1.1 Windows下虚拟机环境+Oracle数据库的安装 网上教程很多，这里学习的话推荐按照这篇博客搭建：15分钟搭建Linux操作系统+Oracle数据库的环境 如果连接丢失了，请移步网盘链接：https://pan.baidu.com/s/1UAY-V0TidR0su9-tuw6CDQ 密码：i2wo 1.2 Mac下虚拟机环境+Oracle数据库的安装 上述搭建过程在Mac下要注意一点，那就是安装完成虚拟机之后，发现上面没有管理这个菜单栏，那么如何导入虚拟机文件么？ 双击.ova文件即可 2.Oracle数据库的基本概念2.1一个 Oracle 服务器 是一个数据管理系统(RDBMS)，它提供开放的, 全面的, 近乎完整的信息管理 由一个Oracle 实例 和一个 Oracle 数据库组成 Oracle 数据库: 位于硬盘上实际存放数据的文件, 这些文件组织在一起, 成为一个逻辑整体, 即为 Oracle 数据库。 因此在 Oracle 看来, “数据库” 是指硬盘上文件的逻辑集合, 必须要与内存里实例合作, 才能对外提供数据管理服务。 Oracle 实例: 位于物理内存里的数据结构. 它由一个共享的内存池和多个后台进程所组成, 共享的内存池可以被所有进程访问。 用户如果要存取数据库(也就是硬盘上的文件) 里的数据, 必须通过实例才能实现, 不能直接读取硬盘上的文件。 2.2 Oracle数据库的结构 2.3 管理机制 oracle：基于用户的管理机制 创建一个信息系统, 给你分配一个用户, 创建表空间 ..创建表.. mysql：基于数据库的管理机制 创建一个信息系统,创建一个数据库 3.基本的select语句3.1 简单使用规则12SELECT *|&#123;[DISTINCT] column|expression [alias],...&#125;FROM table; 说明 SQL 语言大小写不敏感 SQL 可以写在一行或者多行 关键字（例如select）不能被缩写也不能分行 各子句一般要分行写 使用缩进提高语句的可读性 总结 select后面可以是属性列 12SELECT last_name, salaryFROM employees; select后面可以是表达式 12SELECT last_name, salary, salary + 300FROM employees; select后面可以是函数 3.2 列的别名 重命名一个列 便于计算 紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写 AS可以省略；当别名没有空格的时候，双引号可以省略 12345SELECT last_name "Name", salary*12 "Annual Salary"FROM employees;SELECT last_name AS name, commission_pct commFROM employees; -- 省略双引号，省略as 3.3 连接符 把列与列，列与字符连接在一起 用 ‘||’表示 可以用来‘合成’列 12SELECT last_name||job_id AS "Employees"FROM employees; 3.4 字符串 字符串可以是 SELECT 列表中的一个字符,数字,日期 日期和字符只能在单引号中出现（单引号，单引号，单引号） 每当返回一行时，字符串被输出一次 123SELECT last_name ||' is a '||job_id AS "Employee Details"FROM employees; 3.5 捣蛋鬼NULL 空值是无效的，未指定的，未知的或不可预知的值 空值不是空格或者0 注意点： 任何表达式和null运算都为空 null != null （查询不为空的时候，使用的是 xx is not null ，而不是 xx !=null） 4. 过滤和排序4.1 过滤 使用where语句，将不满足条件的语句过滤掉 where 子句紧随 from 子句 between: 来显示在一个区间内的值(包含两端) in: 显示列表中的值 like: 模糊查询 % 代表零个或多个字符(任意个字符) _代表一个字符 123SELECT *|&#123;[DISTINCT] column|expression [alias],...&#125;FROM table[WHERE condition(s)]; 4.2 字符和日期 字符和日期要包含在单引号中（单引号，单引号，单引号） 字符大小写敏感，日期格式敏感 默认的日期格式是 DD-MON-RR 4.3 排序 使用 ORDER BY 子句排序 ASC（ascend）: 升序 DESC（descend）: 降序 排序的规则 可以按照select语句中的列名排序 可以按照别名列名排序 可以按照select语句中的列名的顺序值排序 如果要按照多列进行排序，则规则是先按照第一列排序，如果相同，则按照第二列排序；以此类推 Desc: 5 单行函数5.1 SQL函数 SQL 函数 注意：函数可以没有参数，但必须要有返回值 两种 SQL 函数 5.2单行函数 操作数据对象 接受参数返回一个结果 只对一行进行变换 每行返回一个结果 可以转换数据类型 可以嵌套 参数可以是一列或一个值 6.分组函数6.1 什么是分组函数 分组函数作用于一组数据，并对一组数据返回一个值。 AVG COUNT MAX MIN SUM 12345SELECT [column,] group_function(column), ...FROM table[WHERE condition][GROUP BY column][ORDER BY column]; 6.2 GROUP BY 子句 在SELECT 列表中所有未包含在组函数中的列都应该包含在 GROUP BY 子句中 包含在 GROUP BY 子句中的列不必包含在SELECT 列表中 不能在 WHERE 子句中使用组函数（注意） 可以在 HAVING 子句中使用组函数]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-其他：顺时针旋转矩阵]]></title>
    <url>%2F2018%2F01%2F18%2F004%E5%85%B6%E4%BB%96%EF%BC%8C%E9%A1%BA%E6%97%B6%E9%92%88%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1.题目描述 有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。 给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵,保证N小于等于300。 测试样例：[[1,2,3],[4,5,6],[7,8,9]],3 返回：[[7,4,1],[8,5,2],[9,6,3]] 2.代码编写 提交代码 1234567891011121314151617181920212223242526/***************** * 思想： * 在旋转的时候，我们应该一行一行或者一列一列的来考虑 * 如果按照一行一行来考虑，那么: * 原矩阵的第一行会变成最后一列 * 第二行会变成倒数第二列 * ......................**********************/class Rotate &#123;public: vector&lt;vector&lt;int&gt; &gt; rotateMatrix(vector&lt;vector&lt;int&gt; &gt; mat, int n) &#123; // write code here vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n)); int k = n - 1; // 从最后一列开始，然后倒数第二列，倒数第三列 // 按行遍历原数组：mat for (vector&lt;vector&lt;int&gt; &gt;::iterator p = mat.begin(); p != mat.end();++p) &#123; for (int i = 0; i &lt; n; i++) &#123; res[i][k] = (*p)[i]; // p是一个指针，指向的是一个“街区” &#125; k--; &#125;// end for return res; &#125;&#125;; 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;/***************** * 思想： * 在旋转的时候，我们应该一行一行或者一列一列的来考虑 * 如果按照一行一行来考虑，那么: * 原矩阵的第一行会变成最后一列 * 第二行会变成倒数第二列 * ..............**********************/class Rotate &#123;public: vector&lt;vector&lt;int&gt; &gt; rotateMatrix(vector&lt;vector&lt;int&gt; &gt; mat, int n) &#123; // write code here vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n)); int k = n - 1; // 从最后一列开始，然后倒数第二列，倒数第三列 // 按行遍历原数组：mat for (vector&lt;vector&lt;int&gt; &gt;::iterator p = mat.begin(); p != mat.end();++p) &#123; for (int i = 0; i &lt; n; i++) &#123; res[i][k] = (*p)[i]; // p是一个指针，指向的是一个“街区” &#125; k--; &#125;// end for return res; &#125;&#125;;// ===================== 测试代码 ======================== //void print(vector&lt;vector&lt;int&gt; &gt; &amp;mat, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; mat[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; vector&lt;vector&lt;int&gt; &gt; mat(&#123; &#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125; &#125;); int n = 3; cout &lt;&lt; "before:" &lt;&lt; endl; print(mat, 3); Rotate r; vector&lt;vector&lt;int&gt; &gt; res = r.rotateMatrix(mat, n); cout &lt;&lt; "after:" &lt;&lt; endl; print(res, 3); return 0;&#125; 3.小结 讨论区有人提出可以找规律，直接使用mat[i][j]被旋转到了mat[j][n-i-1]的位置 脑子果然是个好东西，以后一定要好好用用]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>简单编程题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-去哪儿：字符串替换]]></title>
    <url>%2F2018%2F01%2F17%2F003%E5%8E%BB%E5%93%AA%E5%84%BF%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[1.题目描述 请你实现一个简单的字符串替换函数。原串中需要替换的占位符为”%s”,请按照参数列表的顺序一一替换占位符。若参数列表的字符数大于占位符个数。则将剩下的参数字符添加到字符串的结尾。 给定一个字符串A，同时给定它的长度n及参数字符数组arg，请返回替换后的字符串。保证参数个数大于等于占位符个数。保证原串由大小写英文字母组成，同时长度小于等于500。 测试样例：&quot;A%sC%sE&quot;,7,[&#39;B&#39;,&#39;D&#39;,&#39;F&#39;] 返回：&quot;ABCDEF&quot; 2.代码编写123456789101112131415161718192021222324252627282930313233/********************************************* 思路：* 使用两个指针，分别一前一后；* 如果这两个指针下的值恰好对应为%s，那么替换*********************************************/class StringFormat &#123;public: string formatString(string A, int n, vector&lt;char&gt; arg, int m) &#123; // write code here char buf[505] = &#123;0&#125;; // 最终的结果存储数组 int i = 0, j = 0; // 循环变量 int pre = 0, cur=1; // 指针循环变量 while (pre &lt; n) &#123; if (A[pre] == '%' &amp;&amp; cur&lt;n &amp;&amp; A[cur] == 's') &#123; buf[i++] = arg[j++]; pre += 2; cur += 2; &#125; else &#123; buf[i++] = A[pre]; ++pre; ++cur; &#125; &#125; // end while // 如果vector中参数多了，那么添加在最后 while (j &lt; arg.size()) &#123; buf[i++] = arg[j++]; &#125; return string(buf); &#125;&#125;; 3.小结 其实一开始的想法是直接查找”%s”的位置，然后字符串替换 但是后来想到可以用指针的形式练习一下，所以最后就用指针的方式做了 看了一下大家讨论的结果 有人提出把”%s”最为分割符，分割出数组，然后在连接起来，感觉很不错的样子 还有人提出利用正则表达式，厉害]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016校招真题-京东：抛小球]]></title>
    <url>%2F2018%2F01%2F17%2F002%E4%BA%AC%E4%B8%9C%EF%BC%8C%E6%8A%9B%E5%B0%8F%E7%90%83%2F</url>
    <content type="text"><![CDATA[1.题目描述 小东和三个朋友一起在楼上抛小球，他们站在楼房的不同层，假设小东站的楼层距离地面N米，球从他手里自由落下，每次落地后反跳回上次下落高度的一半，并以此类推知道全部落到地面不跳，求4个小球一共经过了多少米？(数字都为整数)给定四个整数A,B,C,D，请返回所求结果。 测试样例：100,90,80,70 结果：1020 2.代码编写12345678910111213141516171819202122232425class Balls &#123;public: int calcDistance(int A, int B, int C, int D) &#123; // write code here return getHeight(A) + getHeight(B) + getHeight(C) + getHeight(D); &#125;private: int getHeight(float h)&#123; float sum = h; // 第一次降落 while(h &gt; 0.0001)&#123; // 只要是从高度大于0的地方降落，都会回弹降落高度的一半 h = h/2; // 回弹到原来高度的一半 sum += 2*h; // 再一次落地时，其实包含上去和下来 &#125; // return sum; // 题目要求最后的结果为整数，那么只有两种处理方式 // 1)：舍去多余的部分 2)：结果+0.5取整数 /***************************************** 函数名: ceil 用 法: double ceil(double x); 功 能: 返回大于或者等于指定表达式的最小整数 ******************************************/ return ceil(sum); &#125; &#125;; 3.小结 我认为这道题目考察的是对整数的处理，也就是说，不可以直接使用int型的高度 但是看到讨论区别人的代码后，感觉思路开阔了很多，有人指出，这就是等比数列求极限 以下是等比数列求极限思想代码 12345678class Balls &#123;public: int calcDistance(int A, int B, int C, int D) &#123; // write code here return 3*(A+B+C+D); &#125;&#125;;]]></content>
      <categories>
        <category>2016校招编程题</category>
      </categories>
      <tags>
        <tag>2016校招编程题</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组类型，指针数组类型以及数组类型的指针]]></title>
    <url>%2F2018%2F01%2F16%2F001%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[C/C++中有数组类型，指针数组，数组类型的指针，有人称之为压死C语言初学者的三座大山，那么如何区分呢？ 1.数组类型12345678910111213141516171819202122232425#include &lt;stdio.h&gt;// 数组类型int main()&#123; // int a[10]; // 这是我们常用的定义数组的方式 // 定义一个数组类型 int[10] typedef int(MyArrayType)[10]; // 注意，这里MyArrayType就是一个数组类型，这个数组类型大小为10个int类型的内存大小 MyArrayType a; // 相当于int a[10]; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; a[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("a[i] = %d\n", i, a[i]); &#125; return 0;&#125; 2.指针数组1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;// 指针数组类型int main()&#123; // 定义一个指向大小为10个int类型内存的指针数组类型 typedef int(*pMyArrayType)[10]; int a[10]; pMyArrayType p = &amp;a; // 这里为什么要对a取地址，想想？？ easy // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*p)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("p[%d] = %d\t", i, (*p)[i]); printf("a[%d] = %d\n", i, a[i]); &#125; return 0;&#125; 3.数组类型的指针1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;// 数组类型的指针int main()&#123; // 1.我们可以定义一个数组类型，然后用这个类型来定义数组类型的指针 // 定义一个数组类型 int[10] typedef int(MyArrayType)[10]; // 注意，这里MyArrayType就是一个数组类型，这个数组类型大小为10个int类型的内存大小 MyArrayType* p; int a[10]; p = &amp;a; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*p)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("p[%d] = %d\t", i, (*p)[i]); printf("a[%d] = %d\n", i, a[i]); &#125; printf("-----------------------------------------------------------\n"); // 2.直接定义 int(*pArr)[10]; // 注意，这里的pArr是变量的名字，不是类型，不可以用来定义新的变量 int b[10]; pArr = &amp;b; // 赋值 for (int i = 0; i &lt; 10; i++) &#123; (*pArr)[i] = i + 1; &#125; // 打印 for (int i = 0; i &lt; 10; i++) &#123; printf("pArr[%d] = %d\t", i, (*pArr)[i]); printf("b[%d] = %d\n", i, b[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++难点</tag>
      </tags>
  </entry>
</search>
